!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/cristian-dev/Projets/tock/chips/stm32f4xx/src/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	//
A	gpio.rs	/^    A = 0b000,$/;"	e	enum:PortId
ADC1	rcc.rs	/^    ADC1,$/;"	e	enum:PCLK2
ADCStatus	adc.rs	/^enum ADCStatus {$/;"	g
AF0	gpio.rs	/^    AF0 = 0b0000,$/;"	e	enum:AlternateFunction
AF1	gpio.rs	/^    AF1 = 0b0001,$/;"	e	enum:AlternateFunction
AF10	gpio.rs	/^    AF10 = 0b1010,$/;"	e	enum:AlternateFunction
AF11	gpio.rs	/^    AF11 = 0b1011,$/;"	e	enum:AlternateFunction
AF12	gpio.rs	/^    AF12 = 0b1100,$/;"	e	enum:AlternateFunction
AF13	gpio.rs	/^    AF13 = 0b1101,$/;"	e	enum:AlternateFunction
AF14	gpio.rs	/^    AF14 = 0b1110,$/;"	e	enum:AlternateFunction
AF15	gpio.rs	/^    AF15 = 0b1111,$/;"	e	enum:AlternateFunction
AF2	gpio.rs	/^    AF2 = 0b0010,$/;"	e	enum:AlternateFunction
AF3	gpio.rs	/^    AF3 = 0b0011,$/;"	e	enum:AlternateFunction
AF4	gpio.rs	/^    AF4 = 0b0100,$/;"	e	enum:AlternateFunction
AF5	gpio.rs	/^    AF5 = 0b0101,$/;"	e	enum:AlternateFunction
AF6	gpio.rs	/^    AF6 = 0b0110,$/;"	e	enum:AlternateFunction
AF7	gpio.rs	/^    AF7 = 0b0111,$/;"	e	enum:AlternateFunction
AF8	gpio.rs	/^    AF8 = 0b1000,$/;"	e	enum:AlternateFunction
AF9	gpio.rs	/^    AF9 = 0b1001,$/;"	e	enum:AlternateFunction
AHB1	rcc.rs	/^    AHB1(HCLK1),$/;"	e	enum:PeripheralClockType
AHB2	rcc.rs	/^    AHB2(HCLK2),$/;"	e	enum:PeripheralClockType
AHB3	rcc.rs	/^    AHB3(HCLK3),$/;"	e	enum:PeripheralClockType
AHBPrescaler	rcc.rs	/^impl TryFrom<usize> for AHBPrescaler {$/;"	c
AHBPrescaler	rcc.rs	/^pub enum AHBPrescaler {$/;"	g
APB1	rcc.rs	/^    APB1(PCLK1),$/;"	e	enum:PeripheralClockType
APB2	rcc.rs	/^    APB2(PCLK2),$/;"	e	enum:PeripheralClockType
APBPrescaler	rcc.rs	/^impl TryFrom<usize> for APBPrescaler {$/;"	c
APBPrescaler	rcc.rs	/^pub enum APBPrescaler {$/;"	g
AbortReceive	can.rs	/^    AbortReceive,$/;"	e	enum:AsyncAction
Aborted	usart.rs	/^    Aborted(Result<(), ErrorCode>),$/;"	e	enum:USARTStateTX
Aborted	usart.rs	/^    Aborted(Result<(), ErrorCode>, hil::uart::Error),$/;"	e	enum:USARTStateRX
Adc	adc.rs	/^impl hil::adc::Adc for Adc<'_> {$/;"	c
Adc	adc.rs	/^impl hil::adc::AdcHighSpeed for Adc<'_> {$/;"	c
Adc	adc.rs	/^impl<'a> Adc<'a> {$/;"	c
Adc	adc.rs	/^pub struct Adc<'a> {$/;"	s
AdcClock	adc.rs	/^impl ClockInterface for AdcClock<'_> {$/;"	c
AdcClock	adc.rs	/^struct AdcClock<'a>(rcc::PeripheralClock<'a>);$/;"	s
AdcCommonRegisters	adc.rs	/^struct AdcCommonRegisters {$/;"	s
AdcRegisters	adc.rs	/^struct AdcRegisters {$/;"	s
AlternateFunction	gpio.rs	/^pub enum AlternateFunction {$/;"	g
AsyncAction	can.rs	/^enum AsyncAction {$/;"	g
B	gpio.rs	/^    B = 0b001,$/;"	e	enum:PortId
BASE_VECTORS	lib.rs	/^pub static BASE_VECTORS: [unsafe extern "C" fn(); 16] = [$/;"	v
Bank1	fsmc.rs	/^    Bank1 = 0,$/;"	e	enum:FsmcBanks
Bank2	fsmc.rs	/^    Bank2 = 1,$/;"	e	enum:FsmcBanks
Bank3	fsmc.rs	/^    Bank3 = 2,$/;"	e	enum:FsmcBanks
Bank4	fsmc.rs	/^    Bank4 = 3,$/;"	e	enum:FsmcBanks
Bit10	adc.rs	/^    Bit10 = 0b01,$/;"	e	enum:DataResolution
Bit12	adc.rs	/^    Bit12 = 0b00,$/;"	e	enum:DataResolution
Bit6	adc.rs	/^    Bit6 = 0b11,$/;"	e	enum:DataResolution
Bit8	adc.rs	/^    Bit8 = 0b10,$/;"	e	enum:DataResolution
BitSegment1	can.rs	/^enum BitSegment1 {$/;"	g
BitSegment2	can.rs	/^enum BitSegment2 {$/;"	g
Byte	dma.rs	/^    Byte = 0b00,$/;"	e	enum:Size
C	gpio.rs	/^    C = 0b010,$/;"	e	enum:PortId
CAN1	rcc.rs	/^    CAN1,$/;"	e	enum:PCLK1
Can	can.rs	/^impl<'a> Can<'a> {$/;"	c
Can	can.rs	/^impl<'a> can::Configure for Can<'_> {$/;"	c
Can	can.rs	/^impl<'a> can::Controller for Can<'_> {$/;"	c
Can	can.rs	/^impl<'a> can::Receive<{ can::STANDARD_CAN_PACKET_SIZE }> for Can<'_> {$/;"	c
Can	can.rs	/^impl<'a> can::Transmit<{ can::STANDARD_CAN_PACKET_SIZE }> for Can<'_> {$/;"	c
Can	can.rs	/^pub struct Can<'a> {$/;"	s
Can	deferred_calls.rs	/^    Can = 4,$/;"	e	enum:DeferredCallTask
CanBtrSjwMax	can.rs	/^    CanBtrSjwMax = 0b11,$/;"	e	enum:SynchronizationJumpWidth
CanBtrSjwMin	can.rs	/^    CanBtrSjwMin = 0b00,$/;"	e	enum:SynchronizationJumpWidth
CanBtrTs1Max	can.rs	/^    CanBtrTs1Max = 0b1111,$/;"	e	enum:BitSegment1
CanBtrTs1Min	can.rs	/^    CanBtrTs1Min = 0b0000,$/;"	e	enum:BitSegment1
CanBtrTs2Max	can.rs	/^    CanBtrTs2Max = 0b0111,$/;"	e	enum:BitSegment2
CanBtrTs2Min	can.rs	/^    CanBtrTs2Min = 0b0000,$/;"	e	enum:BitSegment2
CanClock	can.rs	/^impl ClockInterface for CanClock<'_> {$/;"	c
CanClock	can.rs	/^struct CanClock<'a>(rcc::PeripheralClock<'a>);$/;"	s
CanInterruptMode	can.rs	/^pub enum CanInterruptMode {$/;"	g
CanState	can.rs	/^enum CanState {$/;"	g
Channel	adc.rs	/^    type Channel = Channel;$/;"	t	implementation:Adc
Channel	adc.rs	/^pub enum Channel {$/;"	g
Channel0	adc.rs	/^    Channel0 = 0b00000,$/;"	e	enum:Channel
Channel0	dma.rs	/^    Channel0 = 0b000,$/;"	e	enum:ChannelId
Channel1	adc.rs	/^    Channel1 = 0b00001,$/;"	e	enum:Channel
Channel1	dma.rs	/^    Channel1 = 0b001,$/;"	e	enum:ChannelId
Channel10	adc.rs	/^    Channel10 = 0b01010,$/;"	e	enum:Channel
Channel11	adc.rs	/^    Channel11 = 0b01011,$/;"	e	enum:Channel
Channel12	adc.rs	/^    Channel12 = 0b01100,$/;"	e	enum:Channel
Channel13	adc.rs	/^    Channel13 = 0b01101,$/;"	e	enum:Channel
Channel14	adc.rs	/^    Channel14 = 0b01110,$/;"	e	enum:Channel
Channel15	adc.rs	/^    Channel15 = 0b01111,$/;"	e	enum:Channel
Channel16	adc.rs	/^    Channel16 = 0b10000,$/;"	e	enum:Channel
Channel17	adc.rs	/^    Channel17 = 0b10001,$/;"	e	enum:Channel
Channel18	adc.rs	/^    Channel18 = 0b10010,$/;"	e	enum:Channel
Channel2	adc.rs	/^    Channel2 = 0b00010,$/;"	e	enum:Channel
Channel2	dma.rs	/^    Channel2 = 0b010,$/;"	e	enum:ChannelId
Channel3	adc.rs	/^    Channel3 = 0b00011,$/;"	e	enum:Channel
Channel3	dma.rs	/^    Channel3 = 0b011,$/;"	e	enum:ChannelId
Channel4	adc.rs	/^    Channel4 = 0b00100,$/;"	e	enum:Channel
Channel4	dma.rs	/^    Channel4 = 0b100,$/;"	e	enum:ChannelId
Channel5	adc.rs	/^    Channel5 = 0b00101,$/;"	e	enum:Channel
Channel5	dma.rs	/^    Channel5 = 0b101,$/;"	e	enum:ChannelId
Channel6	adc.rs	/^    Channel6 = 0b00110,$/;"	e	enum:Channel
Channel6	dma.rs	/^    Channel6 = 0b110,$/;"	e	enum:ChannelId
Channel7	adc.rs	/^    Channel7 = 0b00111,$/;"	e	enum:Channel
Channel7	dma.rs	/^    Channel7 = 0b111,$/;"	e	enum:ChannelId
Channel8	adc.rs	/^    Channel8 = 0b01000,$/;"	e	enum:Channel
Channel9	adc.rs	/^    Channel9 = 0b01001,$/;"	e	enum:Channel
ChannelId	dma.rs	/^pub enum ChannelId {$/;"	g
ChipSelect	spi.rs	/^    type ChipSelect = &'a crate::gpio::Pin<'a>;$/;"	t	implementation:Spi
Clocks	clk/clocks.rs	/^impl<'a> Clocks<'a> {$/;"	c
Clocks	clk/clocks.rs	/^pub struct Clocks<'a> {$/;"	s
D	gpio.rs	/^    D = 0b011,$/;"	e	enum:PortId
DEFERRED_CALL	can.rs	/^static DEFERRED_CALL: DeferredCall<DeferredCallTask> =$/;"	v
DEFERRED_CALL	fsmc.rs	/^static DEFERRED_CALL: DeferredCall<DeferredCallTask> =$/;"	v
DEFERRED_CALLS	usart.rs	/^static DEFERRED_CALLS: [DeferredCall<DeferredCallTask>; 3] = unsafe {$/;"	v
DMA1	rcc.rs	/^    DMA1,$/;"	e	enum:HCLK1
DMA2	rcc.rs	/^    DMA2,$/;"	e	enum:HCLK1
DMA_Receiving	usart.rs	/^    DMA_Receiving,$/;"	e	enum:USARTStateRX
DMA_Transmitting	usart.rs	/^    DMA_Transmitting,$/;"	e	enum:USARTStateTX
DataResolution	adc.rs	/^enum DataResolution {$/;"	g
Dbg	dbg.rs	/^impl Dbg {$/;"	c
Dbg	dbg.rs	/^pub struct Dbg {$/;"	s
DbgRegisters	dbg.rs	/^struct DbgRegisters {$/;"	s
DeferredCallTask	deferred_calls.rs	/^impl Into<usize> for DeferredCallTask {$/;"	c
DeferredCallTask	deferred_calls.rs	/^impl TryFrom<usize> for DeferredCallTask {$/;"	c
DeferredCallTask	deferred_calls.rs	/^pub enum DeferredCallTask {$/;"	g
Direct	dma.rs	/^    Direct,$/;"	e	enum:TransferMode
Direction	dma.rs	/^pub enum Direction {$/;"	g
Disabled	can.rs	/^    Disabled,$/;"	e	enum:AsyncAction
DivideBy1	rcc.rs	/^    DivideBy1 = 0b000, \/\/ No division$/;"	e	enum:APBPrescaler
DivideBy1	rcc.rs	/^    DivideBy1 = 0b0000,$/;"	e	enum:AHBPrescaler
DivideBy128	rcc.rs	/^    DivideBy128 = 0b1101,$/;"	e	enum:AHBPrescaler
DivideBy16	rcc.rs	/^    DivideBy16 = 0b1011,$/;"	e	enum:AHBPrescaler
DivideBy16	rcc.rs	/^    DivideBy16 = 0b111,$/;"	e	enum:APBPrescaler
DivideBy16	rcc.rs	/^    DivideBy16 = 16,$/;"	e	enum:PLLM
DivideBy2	rcc.rs	/^    DivideBy2 = 0b00,$/;"	e	enum:PLLP
DivideBy2	rcc.rs	/^    DivideBy2 = 0b100,$/;"	e	enum:APBPrescaler
DivideBy2	rcc.rs	/^    DivideBy2 = 0b1000,$/;"	e	enum:AHBPrescaler
DivideBy2	rcc.rs	/^    DivideBy2 = 2,$/;"	e	enum:PLLQ
DivideBy256	rcc.rs	/^    DivideBy256 = 0b1110,$/;"	e	enum:AHBPrescaler
DivideBy3	rcc.rs	/^    DivideBy3,$/;"	e	enum:PLLQ
DivideBy4	rcc.rs	/^    DivideBy4 = 0b01,$/;"	e	enum:PLLP
DivideBy4	rcc.rs	/^    DivideBy4 = 0b1001,$/;"	e	enum:AHBPrescaler
DivideBy4	rcc.rs	/^    DivideBy4 = 0b101,$/;"	e	enum:APBPrescaler
DivideBy4	rcc.rs	/^    DivideBy4,$/;"	e	enum:PLLQ
DivideBy5	rcc.rs	/^    DivideBy5,$/;"	e	enum:PLLQ
DivideBy512	rcc.rs	/^    DivideBy512 = 0b1111,$/;"	e	enum:AHBPrescaler
DivideBy6	rcc.rs	/^    DivideBy6 = 0b10,$/;"	e	enum:PLLP
DivideBy6	rcc.rs	/^    DivideBy6,$/;"	e	enum:PLLQ
DivideBy64	rcc.rs	/^    DivideBy64 = 0b1100,$/;"	e	enum:AHBPrescaler
DivideBy7	rcc.rs	/^    DivideBy7,$/;"	e	enum:PLLQ
DivideBy8	rcc.rs	/^    DivideBy8 = 0b1010,$/;"	e	enum:AHBPrescaler
DivideBy8	rcc.rs	/^    DivideBy8 = 0b11,$/;"	e	enum:PLLP
DivideBy8	rcc.rs	/^    DivideBy8 = 0b110,$/;"	e	enum:APBPrescaler
DivideBy8	rcc.rs	/^    DivideBy8 = 8,$/;"	e	enum:PLLM
DivideBy8	rcc.rs	/^    DivideBy8,$/;"	e	enum:PLLQ
DivideBy9	rcc.rs	/^    DivideBy9,$/;"	e	enum:PLLQ
Dma1	dma.rs	/^impl<'a> Dma1<'a> {$/;"	c
Dma1	dma.rs	/^impl<'a> StreamServer<'a> for Dma1<'a> {$/;"	c
Dma1	dma.rs	/^pub struct Dma1<'a> {$/;"	s
Dma1Peripheral	dma.rs	/^impl Dma1Peripheral {$/;"	c
Dma1Peripheral	dma.rs	/^impl StreamPeripheral for Dma1Peripheral {$/;"	c
Dma1Peripheral	dma.rs	/^pub enum Dma1Peripheral {$/;"	g
Dma2	dma.rs	/^impl<'a> Dma2<'a> {$/;"	c
Dma2	dma.rs	/^impl<'a> StreamServer<'a> for Dma2<'a> {$/;"	c
Dma2	dma.rs	/^pub struct Dma2<'a> {$/;"	s
Dma2Peripheral	dma.rs	/^impl Dma2Peripheral {$/;"	c
Dma2Peripheral	dma.rs	/^impl StreamPeripheral for Dma2Peripheral {$/;"	c
Dma2Peripheral	dma.rs	/^pub enum Dma2Peripheral {$/;"	g
DmaClock	dma.rs	/^impl ClockInterface for DmaClock<'_> {$/;"	c
DmaClock	dma.rs	/^struct DmaClock<'a>(rcc::PeripheralClock<'a>);$/;"	s
DmaRegisters	dma.rs	/^pub struct DmaRegisters {$/;"	s
E	gpio.rs	/^    E = 0b100,$/;"	e	enum:PortId
EXTI_EVENTS	exti.rs	/^pub static mut EXTI_EVENTS: u32 = 0;$/;"	v
Enable	can.rs	/^    Enable,$/;"	e	enum:AsyncAction
EnableError	can.rs	/^    EnableError(kernel::ErrorCode),$/;"	e	enum:AsyncAction
Error	deferred_calls.rs	/^    type Error = ();$/;"	t	implementation:DeferredCallTask
Error	rcc.rs	/^    type Error = &'static str;$/;"	t	implementation:AHBPrescaler
Error	rcc.rs	/^    type Error = &'static str;$/;"	t	implementation:APBPrescaler
Error	rcc.rs	/^    type Error = &'static str;$/;"	t	implementation:PLLQ
Error	rcc.rs	/^    type Error = &'static str;$/;"	t	implementation:SysClockSource
ErrorAndStatusChangeInterrupt	can.rs	/^    ErrorAndStatusChangeInterrupt,$/;"	e	enum:CanInterruptMode
Exti	exti.rs	/^impl<'a> Exti<'a> {$/;"	c
Exti	exti.rs	/^pub struct Exti<'a> {$/;"	s
ExtiClock	exti.rs	/^impl ClockInterface for ExtiClock<'_> {$/;"	c
ExtiClock	exti.rs	/^struct ExtiClock<'a>(&'a syscfg::Syscfg<'a>);$/;"	s
ExtiRegisters	exti.rs	/^struct ExtiRegisters {$/;"	s
F	gpio.rs	/^    F = 0b101,$/;"	e	enum:PortId
FMC	rcc.rs	/^    FMC,$/;"	e	enum:HCLK3
Fifo	dma.rs	/^    Fifo(FifoSize),$/;"	e	enum:TransferMode
Fifo0Interrupt	can.rs	/^    Fifo0Interrupt,$/;"	e	enum:CanInterruptMode
Fifo1Interrupt	can.rs	/^    Fifo1Interrupt,$/;"	e	enum:CanInterruptMode
FifoSize	dma.rs	/^pub enum FifoSize {$/;"	g
Flash	flash.rs	/^impl Flash {$/;"	c
Flash	flash.rs	/^pub struct Flash {$/;"	s
FlashLatency	flash.rs	/^pub enum FlashLatency {$/;"	g
Frequency	tim2.rs	/^    type Frequency = Freq16KHz;$/;"	t	implementation:Tim2
Fsmc	deferred_calls.rs	/^    Fsmc = 0,$/;"	e	enum:DeferredCallTask
Fsmc	fsmc.rs	/^impl Bus8080<'static> for Fsmc<'_> {$/;"	c
Fsmc	fsmc.rs	/^impl<'a> Fsmc<'a> {$/;"	c
Fsmc	fsmc.rs	/^pub struct Fsmc<'a> {$/;"	s
FsmcBank	fsmc.rs	/^pub struct FsmcBank {$/;"	s
FsmcBankRegisters	fsmc.rs	/^struct FsmcBankRegisters {$/;"	s
FsmcBanks	fsmc.rs	/^pub enum FsmcBanks {$/;"	g
FsmcClock	fsmc.rs	/^impl ClockInterface for FsmcClock<'_> {$/;"	c
FsmcClock	fsmc.rs	/^struct FsmcClock<'a>(rcc::PeripheralClock<'a>);$/;"	s
Full	dma.rs	/^    Full = 0b11,$/;"	e	enum:FifoSize
G	gpio.rs	/^    G = 0b110,$/;"	e	enum:PortId
GPIOA	rcc.rs	/^    GPIOA,$/;"	e	enum:HCLK1
GPIOB	rcc.rs	/^    GPIOB,$/;"	e	enum:HCLK1
GPIOC	rcc.rs	/^    GPIOC,$/;"	e	enum:HCLK1
GPIOD	rcc.rs	/^    GPIOD,$/;"	e	enum:HCLK1
GPIOE	rcc.rs	/^    GPIOE,$/;"	e	enum:HCLK1
GPIOF	rcc.rs	/^    GPIOF,$/;"	e	enum:HCLK1
GPIOG	rcc.rs	/^    GPIOG,$/;"	e	enum:HCLK1
GPIOH	rcc.rs	/^    GPIOH,$/;"	e	enum:HCLK1
GpioPorts	gpio.rs	/^impl<'a> GpioPorts<'a> {$/;"	c
GpioPorts	gpio.rs	/^pub struct GpioPorts<'a> {$/;"	s
GpioRegisters	gpio.rs	/^struct GpioRegisters {$/;"	s
H	gpio.rs	/^    H = 0b111,$/;"	e	enum:PortId
HCLK1	rcc.rs	/^pub enum HCLK1 {$/;"	g
HCLK2	rcc.rs	/^pub enum HCLK2 {$/;"	g
HCLK3	rcc.rs	/^pub enum HCLK3 {$/;"	g
HSI	rcc.rs	/^    HSI = 0b0,$/;"	e	enum:PllSource
HSI	rcc.rs	/^    HSI = 0b00,$/;"	e	enum:SysClockSource
Half	dma.rs	/^    Half = 0b01,$/;"	e	enum:FifoSize
HalfWord	dma.rs	/^    HalfWord = 0b01,$/;"	e	enum:Size
Hsi	clk/hsi.rs	/^impl<'a> Hsi<'a> {$/;"	c
Hsi	clk/hsi.rs	/^pub struct Hsi<'a> {$/;"	s
I2C	i2c.rs	/^impl i2c::I2CMaster for I2C<'_> {$/;"	c
I2C	i2c.rs	/^impl<'a> I2C<'a> {$/;"	c
I2C	i2c.rs	/^pub struct I2C<'a> {$/;"	s
I2C1	rcc.rs	/^    I2C1,$/;"	e	enum:PCLK1
I2CClock	i2c.rs	/^impl ClockInterface for I2CClock<'_> {$/;"	c
I2CClock	i2c.rs	/^struct I2CClock<'a>(rcc::PeripheralClock<'a>);$/;"	s
I2CRegisters	i2c.rs	/^struct I2CRegisters {$/;"	s
I2CSpeed	i2c.rs	/^pub enum I2CSpeed {$/;"	g
I2CStatus	i2c.rs	/^enum I2CStatus {$/;"	g
Idle	adc.rs	/^    Idle,$/;"	e	enum:ADCStatus
Idle	i2c.rs	/^    Idle,$/;"	e	enum:I2CStatus
Idle	usart.rs	/^    Idle,$/;"	e	enum:USARTStateRX
Idle	usart.rs	/^    Idle,$/;"	e	enum:USARTStateTX
Initialization	can.rs	/^    Initialization,$/;"	e	enum:CanState
Item	trng.rs	/^    type Item = u32;$/;"	t	implementation:TrngIter
Latency0	flash.rs	/^    Latency0,$/;"	e	enum:FlashLatency
Latency1	flash.rs	/^    Latency1,$/;"	e	enum:FlashLatency
Latency10	flash.rs	/^    Latency10,$/;"	e	enum:FlashLatency
Latency11	flash.rs	/^    Latency11,$/;"	e	enum:FlashLatency
Latency12	flash.rs	/^    Latency12,$/;"	e	enum:FlashLatency
Latency13	flash.rs	/^    Latency13,$/;"	e	enum:FlashLatency
Latency14	flash.rs	/^    Latency14,$/;"	e	enum:FlashLatency
Latency15	flash.rs	/^    Latency15,$/;"	e	enum:FlashLatency
Latency2	flash.rs	/^    Latency2,$/;"	e	enum:FlashLatency
Latency3	flash.rs	/^    Latency3,$/;"	e	enum:FlashLatency
Latency4	flash.rs	/^    Latency4,$/;"	e	enum:FlashLatency
Latency5	flash.rs	/^    Latency5,$/;"	e	enum:FlashLatency
Latency6	flash.rs	/^    Latency6,$/;"	e	enum:FlashLatency
Latency7	flash.rs	/^    Latency7,$/;"	e	enum:FlashLatency
Latency8	flash.rs	/^    Latency8,$/;"	e	enum:FlashLatency
Latency9	flash.rs	/^    Latency9,$/;"	e	enum:FlashLatency
MPU	chip.rs	/^    type MPU = cortexm4::mpu::MPU;$/;"	t	implementation:Stm32f4xx
MemoryToMemory	dma.rs	/^    MemoryToMemory = 0b10,$/;"	e	enum:Direction
MemoryToPeripheral	dma.rs	/^    MemoryToPeripheral = 0b01,$/;"	e	enum:Direction
Msize	dma.rs	/^pub struct Msize(Size);$/;"	s
Normal	can.rs	/^    Normal,$/;"	e	enum:CanState
OTGFS	rcc.rs	/^    OTGFS,$/;"	e	enum:HCLK2
Off	adc.rs	/^    Off,$/;"	e	enum:ADCStatus
OneSample	adc.rs	/^    OneSample,$/;"	e	enum:ADCStatus
PA00	gpio.rs	/^    PA00 = 0b0000000, PA01 = 0b0000001, PA02 = 0b0000010, PA03 = 0b0000011,$/;"	e	enum:PinId
PA01	gpio.rs	/^    PA00 = 0b0000000, PA01 = 0b0000001, PA02 = 0b0000010, PA03 = 0b0000011,$/;"	e	enum:PinId
PA02	gpio.rs	/^    PA00 = 0b0000000, PA01 = 0b0000001, PA02 = 0b0000010, PA03 = 0b0000011,$/;"	e	enum:PinId
PA03	gpio.rs	/^    PA00 = 0b0000000, PA01 = 0b0000001, PA02 = 0b0000010, PA03 = 0b0000011,$/;"	e	enum:PinId
PA04	gpio.rs	/^    PA04 = 0b0000100, PA05 = 0b0000101, PA06 = 0b0000110, PA07 = 0b0000111,$/;"	e	enum:PinId
PA05	gpio.rs	/^    PA04 = 0b0000100, PA05 = 0b0000101, PA06 = 0b0000110, PA07 = 0b0000111,$/;"	e	enum:PinId
PA06	gpio.rs	/^    PA04 = 0b0000100, PA05 = 0b0000101, PA06 = 0b0000110, PA07 = 0b0000111,$/;"	e	enum:PinId
PA07	gpio.rs	/^    PA04 = 0b0000100, PA05 = 0b0000101, PA06 = 0b0000110, PA07 = 0b0000111,$/;"	e	enum:PinId
PA08	gpio.rs	/^    PA08 = 0b0001000, PA09 = 0b0001001, PA10 = 0b0001010, PA11 = 0b0001011,$/;"	e	enum:PinId
PA09	gpio.rs	/^    PA08 = 0b0001000, PA09 = 0b0001001, PA10 = 0b0001010, PA11 = 0b0001011,$/;"	e	enum:PinId
PA10	gpio.rs	/^    PA08 = 0b0001000, PA09 = 0b0001001, PA10 = 0b0001010, PA11 = 0b0001011,$/;"	e	enum:PinId
PA11	gpio.rs	/^    PA08 = 0b0001000, PA09 = 0b0001001, PA10 = 0b0001010, PA11 = 0b0001011,$/;"	e	enum:PinId
PA12	gpio.rs	/^    PA12 = 0b0001100, PA13 = 0b0001101, PA14 = 0b0001110, PA15 = 0b0001111,$/;"	e	enum:PinId
PA13	gpio.rs	/^    PA12 = 0b0001100, PA13 = 0b0001101, PA14 = 0b0001110, PA15 = 0b0001111,$/;"	e	enum:PinId
PA14	gpio.rs	/^    PA12 = 0b0001100, PA13 = 0b0001101, PA14 = 0b0001110, PA15 = 0b0001111,$/;"	e	enum:PinId
PA15	gpio.rs	/^    PA12 = 0b0001100, PA13 = 0b0001101, PA14 = 0b0001110, PA15 = 0b0001111,$/;"	e	enum:PinId
PB00	gpio.rs	/^    PB00 = 0b0010000, PB01 = 0b0010001, PB02 = 0b0010010, PB03 = 0b0010011,$/;"	e	enum:PinId
PB01	gpio.rs	/^    PB00 = 0b0010000, PB01 = 0b0010001, PB02 = 0b0010010, PB03 = 0b0010011,$/;"	e	enum:PinId
PB02	gpio.rs	/^    PB00 = 0b0010000, PB01 = 0b0010001, PB02 = 0b0010010, PB03 = 0b0010011,$/;"	e	enum:PinId
PB03	gpio.rs	/^    PB00 = 0b0010000, PB01 = 0b0010001, PB02 = 0b0010010, PB03 = 0b0010011,$/;"	e	enum:PinId
PB04	gpio.rs	/^    PB04 = 0b0010100, PB05 = 0b0010101, PB06 = 0b0010110, PB07 = 0b0010111,$/;"	e	enum:PinId
PB05	gpio.rs	/^    PB04 = 0b0010100, PB05 = 0b0010101, PB06 = 0b0010110, PB07 = 0b0010111,$/;"	e	enum:PinId
PB06	gpio.rs	/^    PB04 = 0b0010100, PB05 = 0b0010101, PB06 = 0b0010110, PB07 = 0b0010111,$/;"	e	enum:PinId
PB07	gpio.rs	/^    PB04 = 0b0010100, PB05 = 0b0010101, PB06 = 0b0010110, PB07 = 0b0010111,$/;"	e	enum:PinId
PB08	gpio.rs	/^    PB08 = 0b0011000, PB09 = 0b0011001, PB10 = 0b0011010, PB11 = 0b0011011,$/;"	e	enum:PinId
PB09	gpio.rs	/^    PB08 = 0b0011000, PB09 = 0b0011001, PB10 = 0b0011010, PB11 = 0b0011011,$/;"	e	enum:PinId
PB10	gpio.rs	/^    PB08 = 0b0011000, PB09 = 0b0011001, PB10 = 0b0011010, PB11 = 0b0011011,$/;"	e	enum:PinId
PB11	gpio.rs	/^    PB08 = 0b0011000, PB09 = 0b0011001, PB10 = 0b0011010, PB11 = 0b0011011,$/;"	e	enum:PinId
PB12	gpio.rs	/^    PB12 = 0b0011100, PB13 = 0b0011101, PB14 = 0b0011110, PB15 = 0b0011111,$/;"	e	enum:PinId
PB13	gpio.rs	/^    PB12 = 0b0011100, PB13 = 0b0011101, PB14 = 0b0011110, PB15 = 0b0011111,$/;"	e	enum:PinId
PB14	gpio.rs	/^    PB12 = 0b0011100, PB13 = 0b0011101, PB14 = 0b0011110, PB15 = 0b0011111,$/;"	e	enum:PinId
PB15	gpio.rs	/^    PB12 = 0b0011100, PB13 = 0b0011101, PB14 = 0b0011110, PB15 = 0b0011111,$/;"	e	enum:PinId
PC00	gpio.rs	/^    PC00 = 0b0100000, PC01 = 0b0100001, PC02 = 0b0100010, PC03 = 0b0100011,$/;"	e	enum:PinId
PC01	gpio.rs	/^    PC00 = 0b0100000, PC01 = 0b0100001, PC02 = 0b0100010, PC03 = 0b0100011,$/;"	e	enum:PinId
PC02	gpio.rs	/^    PC00 = 0b0100000, PC01 = 0b0100001, PC02 = 0b0100010, PC03 = 0b0100011,$/;"	e	enum:PinId
PC03	gpio.rs	/^    PC00 = 0b0100000, PC01 = 0b0100001, PC02 = 0b0100010, PC03 = 0b0100011,$/;"	e	enum:PinId
PC04	gpio.rs	/^    PC04 = 0b0100100, PC05 = 0b0100101, PC06 = 0b0100110, PC07 = 0b0100111,$/;"	e	enum:PinId
PC05	gpio.rs	/^    PC04 = 0b0100100, PC05 = 0b0100101, PC06 = 0b0100110, PC07 = 0b0100111,$/;"	e	enum:PinId
PC06	gpio.rs	/^    PC04 = 0b0100100, PC05 = 0b0100101, PC06 = 0b0100110, PC07 = 0b0100111,$/;"	e	enum:PinId
PC07	gpio.rs	/^    PC04 = 0b0100100, PC05 = 0b0100101, PC06 = 0b0100110, PC07 = 0b0100111,$/;"	e	enum:PinId
PC08	gpio.rs	/^    PC08 = 0b0101000, PC09 = 0b0101001, PC10 = 0b0101010, PC11 = 0b0101011,$/;"	e	enum:PinId
PC09	gpio.rs	/^    PC08 = 0b0101000, PC09 = 0b0101001, PC10 = 0b0101010, PC11 = 0b0101011,$/;"	e	enum:PinId
PC10	gpio.rs	/^    PC08 = 0b0101000, PC09 = 0b0101001, PC10 = 0b0101010, PC11 = 0b0101011,$/;"	e	enum:PinId
PC11	gpio.rs	/^    PC08 = 0b0101000, PC09 = 0b0101001, PC10 = 0b0101010, PC11 = 0b0101011,$/;"	e	enum:PinId
PC12	gpio.rs	/^    PC12 = 0b0101100, PC13 = 0b0101101, PC14 = 0b0101110, PC15 = 0b0101111,$/;"	e	enum:PinId
PC13	gpio.rs	/^    PC12 = 0b0101100, PC13 = 0b0101101, PC14 = 0b0101110, PC15 = 0b0101111,$/;"	e	enum:PinId
PC14	gpio.rs	/^    PC12 = 0b0101100, PC13 = 0b0101101, PC14 = 0b0101110, PC15 = 0b0101111,$/;"	e	enum:PinId
PC15	gpio.rs	/^    PC12 = 0b0101100, PC13 = 0b0101101, PC14 = 0b0101110, PC15 = 0b0101111,$/;"	e	enum:PinId
PCLK1	rcc.rs	/^pub enum PCLK1 {$/;"	g
PCLK2	rcc.rs	/^pub enum PCLK2 {$/;"	g
PD00	gpio.rs	/^    PD00 = 0b0110000, PD01 = 0b0110001, PD02 = 0b0110010, PD03 = 0b0110011,$/;"	e	enum:PinId
PD01	gpio.rs	/^    PD00 = 0b0110000, PD01 = 0b0110001, PD02 = 0b0110010, PD03 = 0b0110011,$/;"	e	enum:PinId
PD02	gpio.rs	/^    PD00 = 0b0110000, PD01 = 0b0110001, PD02 = 0b0110010, PD03 = 0b0110011,$/;"	e	enum:PinId
PD03	gpio.rs	/^    PD00 = 0b0110000, PD01 = 0b0110001, PD02 = 0b0110010, PD03 = 0b0110011,$/;"	e	enum:PinId
PD04	gpio.rs	/^    PD04 = 0b0110100, PD05 = 0b0110101, PD06 = 0b0110110, PD07 = 0b0110111,$/;"	e	enum:PinId
PD05	gpio.rs	/^    PD04 = 0b0110100, PD05 = 0b0110101, PD06 = 0b0110110, PD07 = 0b0110111,$/;"	e	enum:PinId
PD06	gpio.rs	/^    PD04 = 0b0110100, PD05 = 0b0110101, PD06 = 0b0110110, PD07 = 0b0110111,$/;"	e	enum:PinId
PD07	gpio.rs	/^    PD04 = 0b0110100, PD05 = 0b0110101, PD06 = 0b0110110, PD07 = 0b0110111,$/;"	e	enum:PinId
PD08	gpio.rs	/^    PD08 = 0b0111000, PD09 = 0b0111001, PD10 = 0b0111010, PD11 = 0b0111011,$/;"	e	enum:PinId
PD09	gpio.rs	/^    PD08 = 0b0111000, PD09 = 0b0111001, PD10 = 0b0111010, PD11 = 0b0111011,$/;"	e	enum:PinId
PD10	gpio.rs	/^    PD08 = 0b0111000, PD09 = 0b0111001, PD10 = 0b0111010, PD11 = 0b0111011,$/;"	e	enum:PinId
PD11	gpio.rs	/^    PD08 = 0b0111000, PD09 = 0b0111001, PD10 = 0b0111010, PD11 = 0b0111011,$/;"	e	enum:PinId
PD12	gpio.rs	/^    PD12 = 0b0111100, PD13 = 0b0111101, PD14 = 0b0111110, PD15 = 0b0111111,$/;"	e	enum:PinId
PD13	gpio.rs	/^    PD12 = 0b0111100, PD13 = 0b0111101, PD14 = 0b0111110, PD15 = 0b0111111,$/;"	e	enum:PinId
PD14	gpio.rs	/^    PD12 = 0b0111100, PD13 = 0b0111101, PD14 = 0b0111110, PD15 = 0b0111111,$/;"	e	enum:PinId
PD15	gpio.rs	/^    PD12 = 0b0111100, PD13 = 0b0111101, PD14 = 0b0111110, PD15 = 0b0111111,$/;"	e	enum:PinId
PE00	gpio.rs	/^    PE00 = 0b1000000, PE01 = 0b1000001, PE02 = 0b1000010, PE03 = 0b1000011,$/;"	e	enum:PinId
PE01	gpio.rs	/^    PE00 = 0b1000000, PE01 = 0b1000001, PE02 = 0b1000010, PE03 = 0b1000011,$/;"	e	enum:PinId
PE02	gpio.rs	/^    PE00 = 0b1000000, PE01 = 0b1000001, PE02 = 0b1000010, PE03 = 0b1000011,$/;"	e	enum:PinId
PE03	gpio.rs	/^    PE00 = 0b1000000, PE01 = 0b1000001, PE02 = 0b1000010, PE03 = 0b1000011,$/;"	e	enum:PinId
PE04	gpio.rs	/^    PE04 = 0b1000100, PE05 = 0b1000101, PE06 = 0b1000110, PE07 = 0b1000111,$/;"	e	enum:PinId
PE05	gpio.rs	/^    PE04 = 0b1000100, PE05 = 0b1000101, PE06 = 0b1000110, PE07 = 0b1000111,$/;"	e	enum:PinId
PE06	gpio.rs	/^    PE04 = 0b1000100, PE05 = 0b1000101, PE06 = 0b1000110, PE07 = 0b1000111,$/;"	e	enum:PinId
PE07	gpio.rs	/^    PE04 = 0b1000100, PE05 = 0b1000101, PE06 = 0b1000110, PE07 = 0b1000111,$/;"	e	enum:PinId
PE08	gpio.rs	/^    PE08 = 0b1001000, PE09 = 0b1001001, PE10 = 0b1001010, PE11 = 0b1001011,$/;"	e	enum:PinId
PE09	gpio.rs	/^    PE08 = 0b1001000, PE09 = 0b1001001, PE10 = 0b1001010, PE11 = 0b1001011,$/;"	e	enum:PinId
PE10	gpio.rs	/^    PE08 = 0b1001000, PE09 = 0b1001001, PE10 = 0b1001010, PE11 = 0b1001011,$/;"	e	enum:PinId
PE11	gpio.rs	/^    PE08 = 0b1001000, PE09 = 0b1001001, PE10 = 0b1001010, PE11 = 0b1001011,$/;"	e	enum:PinId
PE12	gpio.rs	/^    PE12 = 0b1001100, PE13 = 0b1001101, PE14 = 0b1001110, PE15 = 0b1001111,$/;"	e	enum:PinId
PE13	gpio.rs	/^    PE12 = 0b1001100, PE13 = 0b1001101, PE14 = 0b1001110, PE15 = 0b1001111,$/;"	e	enum:PinId
PE14	gpio.rs	/^    PE12 = 0b1001100, PE13 = 0b1001101, PE14 = 0b1001110, PE15 = 0b1001111,$/;"	e	enum:PinId
PE15	gpio.rs	/^    PE12 = 0b1001100, PE13 = 0b1001101, PE14 = 0b1001110, PE15 = 0b1001111,$/;"	e	enum:PinId
PF00	gpio.rs	/^    PF00 = 0b1010000, PF01 = 0b1010001, PF02 = 0b1010010, PF03 = 0b1010011,$/;"	e	enum:PinId
PF01	gpio.rs	/^    PF00 = 0b1010000, PF01 = 0b1010001, PF02 = 0b1010010, PF03 = 0b1010011,$/;"	e	enum:PinId
PF02	gpio.rs	/^    PF00 = 0b1010000, PF01 = 0b1010001, PF02 = 0b1010010, PF03 = 0b1010011,$/;"	e	enum:PinId
PF03	gpio.rs	/^    PF00 = 0b1010000, PF01 = 0b1010001, PF02 = 0b1010010, PF03 = 0b1010011,$/;"	e	enum:PinId
PF04	gpio.rs	/^    PF04 = 0b1010100, PF05 = 0b1010101, PF06 = 0b1010110, PF07 = 0b1010111,$/;"	e	enum:PinId
PF05	gpio.rs	/^    PF04 = 0b1010100, PF05 = 0b1010101, PF06 = 0b1010110, PF07 = 0b1010111,$/;"	e	enum:PinId
PF06	gpio.rs	/^    PF04 = 0b1010100, PF05 = 0b1010101, PF06 = 0b1010110, PF07 = 0b1010111,$/;"	e	enum:PinId
PF07	gpio.rs	/^    PF04 = 0b1010100, PF05 = 0b1010101, PF06 = 0b1010110, PF07 = 0b1010111,$/;"	e	enum:PinId
PF08	gpio.rs	/^    PF08 = 0b1011000, PF09 = 0b1011001, PF10 = 0b1011010, PF11 = 0b1011011,$/;"	e	enum:PinId
PF09	gpio.rs	/^    PF08 = 0b1011000, PF09 = 0b1011001, PF10 = 0b1011010, PF11 = 0b1011011,$/;"	e	enum:PinId
PF10	gpio.rs	/^    PF08 = 0b1011000, PF09 = 0b1011001, PF10 = 0b1011010, PF11 = 0b1011011,$/;"	e	enum:PinId
PF11	gpio.rs	/^    PF08 = 0b1011000, PF09 = 0b1011001, PF10 = 0b1011010, PF11 = 0b1011011,$/;"	e	enum:PinId
PF12	gpio.rs	/^    PF12 = 0b1011100, PF13 = 0b1011101, PF14 = 0b1011110, PF15 = 0b1011111,$/;"	e	enum:PinId
PF13	gpio.rs	/^    PF12 = 0b1011100, PF13 = 0b1011101, PF14 = 0b1011110, PF15 = 0b1011111,$/;"	e	enum:PinId
PF14	gpio.rs	/^    PF12 = 0b1011100, PF13 = 0b1011101, PF14 = 0b1011110, PF15 = 0b1011111,$/;"	e	enum:PinId
PF15	gpio.rs	/^    PF12 = 0b1011100, PF13 = 0b1011101, PF14 = 0b1011110, PF15 = 0b1011111,$/;"	e	enum:PinId
PG00	gpio.rs	/^    PG00 = 0b1100000, PG01 = 0b1100001, PG02 = 0b1100010, PG03 = 0b1100011,$/;"	e	enum:PinId
PG01	gpio.rs	/^    PG00 = 0b1100000, PG01 = 0b1100001, PG02 = 0b1100010, PG03 = 0b1100011,$/;"	e	enum:PinId
PG02	gpio.rs	/^    PG00 = 0b1100000, PG01 = 0b1100001, PG02 = 0b1100010, PG03 = 0b1100011,$/;"	e	enum:PinId
PG03	gpio.rs	/^    PG00 = 0b1100000, PG01 = 0b1100001, PG02 = 0b1100010, PG03 = 0b1100011,$/;"	e	enum:PinId
PG04	gpio.rs	/^    PG04 = 0b1100100, PG05 = 0b1100101, PG06 = 0b1100110, PG07 = 0b1100111,$/;"	e	enum:PinId
PG05	gpio.rs	/^    PG04 = 0b1100100, PG05 = 0b1100101, PG06 = 0b1100110, PG07 = 0b1100111,$/;"	e	enum:PinId
PG06	gpio.rs	/^    PG04 = 0b1100100, PG05 = 0b1100101, PG06 = 0b1100110, PG07 = 0b1100111,$/;"	e	enum:PinId
PG07	gpio.rs	/^    PG04 = 0b1100100, PG05 = 0b1100101, PG06 = 0b1100110, PG07 = 0b1100111,$/;"	e	enum:PinId
PG08	gpio.rs	/^    PG08 = 0b1101000, PG09 = 0b1101001, PG10 = 0b1101010, PG11 = 0b1101011,$/;"	e	enum:PinId
PG09	gpio.rs	/^    PG08 = 0b1101000, PG09 = 0b1101001, PG10 = 0b1101010, PG11 = 0b1101011,$/;"	e	enum:PinId
PG10	gpio.rs	/^    PG08 = 0b1101000, PG09 = 0b1101001, PG10 = 0b1101010, PG11 = 0b1101011,$/;"	e	enum:PinId
PG11	gpio.rs	/^    PG08 = 0b1101000, PG09 = 0b1101001, PG10 = 0b1101010, PG11 = 0b1101011,$/;"	e	enum:PinId
PG12	gpio.rs	/^    PG12 = 0b1101100, PG13 = 0b1101101, PG14 = 0b1101110, PG15 = 0b1101111,$/;"	e	enum:PinId
PG13	gpio.rs	/^    PG12 = 0b1101100, PG13 = 0b1101101, PG14 = 0b1101110, PG15 = 0b1101111,$/;"	e	enum:PinId
PG14	gpio.rs	/^    PG12 = 0b1101100, PG13 = 0b1101101, PG14 = 0b1101110, PG15 = 0b1101111,$/;"	e	enum:PinId
PG15	gpio.rs	/^    PG12 = 0b1101100, PG13 = 0b1101101, PG14 = 0b1101110, PG15 = 0b1101111,$/;"	e	enum:PinId
PH00	gpio.rs	/^    PH00 = 0b1110000, PH01 = 0b1110001,$/;"	e	enum:PinId
PH01	gpio.rs	/^    PH00 = 0b1110000, PH01 = 0b1110001,$/;"	e	enum:PinId
PLLCLK	rcc.rs	/^    PLLCLK = 0b10,$/;"	e	enum:SysClockSource
PLLM	rcc.rs	/^pub(crate) enum PLLM {$/;"	g
PLLP	rcc.rs	/^pub(crate) enum PLLP {$/;"	g
PLLQ	rcc.rs	/^impl TryFrom<usize> for PLLQ {$/;"	c
PLLQ	rcc.rs	/^pub(crate) enum PLLQ {$/;"	g
Peripheral	dma.rs	/^    type Peripheral = Dma1Peripheral;$/;"	t	implementation:Dma1
Peripheral	dma.rs	/^    type Peripheral = Dma2Peripheral;$/;"	t	implementation:Dma2
Peripheral	dma.rs	/^    type Peripheral: StreamPeripheral + core::marker::Copy + PartialEq + Into<StreamId> + Debug;$/;"	t	interface:StreamServer
PeripheralClock	rcc.rs	/^impl<'a> ClockInterface for PeripheralClock<'a> {$/;"	c
PeripheralClock	rcc.rs	/^impl<'a> PeripheralClock<'a> {$/;"	c
PeripheralClock	rcc.rs	/^pub struct PeripheralClock<'a> {$/;"	s
PeripheralClockType	rcc.rs	/^pub enum PeripheralClockType {$/;"	g
PeripheralToMemory	dma.rs	/^    PeripheralToMemory = 0b00,$/;"	e	enum:Direction
Pin	gpio.rs	/^impl hil::gpio::Configure for Pin<'_> {$/;"	c
Pin	gpio.rs	/^impl hil::gpio::Input for Pin<'_> {$/;"	c
Pin	gpio.rs	/^impl hil::gpio::Output for Pin<'_> {$/;"	c
Pin	gpio.rs	/^impl<'a> Pin<'a> {$/;"	c
Pin	gpio.rs	/^impl<'a> hil::gpio::Interrupt<'a> for Pin<'a> {$/;"	c
Pin	gpio.rs	/^pub struct Pin<'a> {$/;"	s
PinId	gpio.rs	/^impl PinId {$/;"	c
PinId	gpio.rs	/^pub enum PinId {$/;"	g
Pll	clk/pll.rs	/^impl<'a> Pll<'a> {$/;"	c
Pll	clk/pll.rs	/^pub struct Pll<'a> {$/;"	s
PllSource	rcc.rs	/^pub(crate) enum PllSource {$/;"	g
Port	gpio.rs	/^impl Port<'_> {$/;"	c
Port	gpio.rs	/^pub struct Port<'a> {$/;"	s
PortClock	gpio.rs	/^impl ClockInterface for PortClock<'_> {$/;"	c
PortClock	gpio.rs	/^struct PortClock<'a>(rcc::PeripheralClock<'a>);$/;"	s
PortId	gpio.rs	/^pub enum PortId {$/;"	g
Psize	dma.rs	/^pub struct Psize(Size);$/;"	s
Quarter	dma.rs	/^    Quarter = 0b00,$/;"	e	enum:FifoSize
RNG	rcc.rs	/^    RNG,$/;"	e	enum:HCLK2
Rcc	rcc.rs	/^impl Rcc {$/;"	c
Rcc	rcc.rs	/^pub struct Rcc {$/;"	s
RccRegisters	rcc.rs	/^struct RccRegisters {$/;"	s
Reading	i2c.rs	/^    Reading,$/;"	e	enum:I2CStatus
RngClock	trng.rs	/^impl ClockInterface for RngClock<'_> {$/;"	c
RngClock	trng.rs	/^struct RngClock<'a>(rcc::PeripheralClock<'a>);$/;"	s
RngRegisters	trng.rs	/^pub struct RngRegisters {$/;"	s
RunningError	can.rs	/^    RunningError(can::Error),$/;"	e	enum:CanState
RxDMA	spi.rs	/^pub struct RxDMA<'a>(pub &'a dma::Stream<'a, Dma1<'a>>);$/;"	s
RxDMA	usart.rs	/^pub struct RxDMA<'a, DMA: dma::StreamServer<'a>>(pub &'a dma::Stream<'a, DMA>);$/;"	s
SPI3	rcc.rs	/^    SPI3,$/;"	e	enum:PCLK1
SPI3_RX	dma.rs	/^    SPI3_RX,$/;"	e	enum:Dma1Peripheral
SPI3_TX	dma.rs	/^    SPI3_TX,$/;"	e	enum:Dma1Peripheral
SYSCFG	rcc.rs	/^    SYSCFG,$/;"	e	enum:PCLK2
Size	dma.rs	/^pub enum Size {$/;"	g
Sleep	can.rs	/^    Sleep,$/;"	e	enum:CanState
Speed100k	i2c.rs	/^    Speed100k,$/;"	e	enum:I2CSpeed
Speed400k	i2c.rs	/^    Speed400k,$/;"	e	enum:I2CSpeed
Spi	spi.rs	/^impl<'a> Spi<'a> {$/;"	c
Spi	spi.rs	/^impl<'a> dma::StreamClient<'a, Dma1<'a>> for Spi<'a> {$/;"	c
Spi	spi.rs	/^impl<'a> spi::SpiMaster for Spi<'a> {$/;"	c
Spi	spi.rs	/^pub struct Spi<'a> {$/;"	s
SpiClock	spi.rs	/^impl ClockInterface for SpiClock<'_> {$/;"	c
SpiClock	spi.rs	/^pub struct SpiClock<'a>(pub rcc::PeripheralClock<'a>);$/;"	s
SpiRegisters	spi.rs	/^pub struct SpiRegisters {$/;"	s
State	can.rs	/^impl From<CanState> for can::State {$/;"	c
Stm32f4xx	chip.rs	/^impl<'a, I: InterruptService<DeferredCallTask> + 'a> Chip for Stm32f4xx<'a, I> {$/;"	c
Stm32f4xx	chip.rs	/^impl<'a, I: InterruptService<DeferredCallTask> + 'a> Stm32f4xx<'a, I> {$/;"	c
Stm32f4xx	chip.rs	/^pub struct Stm32f4xx<'a, I: InterruptService<DeferredCallTask> + 'a> {$/;"	s
Stm32f4xxDefaultPeripherals	chip.rs	/^impl<'a> InterruptService<DeferredCallTask> for Stm32f4xxDefaultPeripherals<'a> {$/;"	c
Stm32f4xxDefaultPeripherals	chip.rs	/^impl<'a> Stm32f4xxDefaultPeripherals<'a> {$/;"	c
Stm32f4xxDefaultPeripherals	chip.rs	/^pub struct Stm32f4xxDefaultPeripherals<'a> {$/;"	s
Stream	dma.rs	/^impl<'a, DMA: StreamServer<'a>> Stream<'a, DMA> {$/;"	c
Stream	dma.rs	/^pub struct Stream<'a, DMA: StreamServer<'a>> {$/;"	s
Stream0	dma.rs	/^    Stream0 = 0,$/;"	e	enum:StreamId
Stream1	dma.rs	/^    Stream1 = 1,$/;"	e	enum:StreamId
Stream2	dma.rs	/^    Stream2 = 2,$/;"	e	enum:StreamId
Stream3	dma.rs	/^    Stream3 = 3,$/;"	e	enum:StreamId
Stream4	dma.rs	/^    Stream4 = 4,$/;"	e	enum:StreamId
Stream5	dma.rs	/^    Stream5 = 5,$/;"	e	enum:StreamId
Stream6	dma.rs	/^    Stream6 = 6,$/;"	e	enum:StreamId
Stream7	dma.rs	/^    Stream7 = 7,$/;"	e	enum:StreamId
StreamClient	dma.rs	/^pub trait StreamClient<'a, DMA: StreamServer<'a>> {$/;"	i
StreamId	dma.rs	/^impl From<Dma1Peripheral> for StreamId {$/;"	c
StreamId	dma.rs	/^impl From<Dma2Peripheral> for StreamId {$/;"	c
StreamId	dma.rs	/^pub enum StreamId {$/;"	g
StreamPeripheral	dma.rs	/^pub trait StreamPeripheral {$/;"	i
StreamServer	dma.rs	/^pub trait StreamServer<'a> {$/;"	i
SynchronizationJumpWidth	can.rs	/^enum SynchronizationJumpWidth {$/;"	g
SysClockSource	rcc.rs	/^impl TryFrom<u32> for SysClockSource {$/;"	c
SysClockSource	rcc.rs	/^pub enum SysClockSource {$/;"	g
Syscfg	syscfg.rs	/^impl<'a> Syscfg<'a> {$/;"	c
Syscfg	syscfg.rs	/^pub struct Syscfg<'a> {$/;"	s
SyscfgClock	syscfg.rs	/^impl ClockInterface for SyscfgClock<'_> {$/;"	c
SyscfgClock	syscfg.rs	/^struct SyscfgClock<'a>(rcc::PeripheralClock<'a>);$/;"	s
SyscfgRegisters	syscfg.rs	/^struct SyscfgRegisters {$/;"	s
TIM2	rcc.rs	/^    TIM2,$/;"	e	enum:PCLK1
ThreeFourths	dma.rs	/^    ThreeFourths = 0b10,$/;"	e	enum:FifoSize
Ticks	tim2.rs	/^    type Ticks = Ticks32;$/;"	t	implementation:Tim2
Tim2	tim2.rs	/^impl Time for Tim2<'_> {$/;"	c
Tim2	tim2.rs	/^impl<'a> Alarm<'a> for Tim2<'a> {$/;"	c
Tim2	tim2.rs	/^impl<'a> Counter<'a> for Tim2<'a> {$/;"	c
Tim2	tim2.rs	/^impl<'a> Tim2<'a> {$/;"	c
Tim2	tim2.rs	/^pub struct Tim2<'a> {$/;"	s
Tim2Clock	tim2.rs	/^impl ClockInterface for Tim2Clock<'_> {$/;"	c
Tim2Clock	tim2.rs	/^struct Tim2Clock<'a>(rcc::PeripheralClock<'a>);$/;"	s
Tim2Registers	tim2.rs	/^struct Tim2Registers {$/;"	s
TransferMode	dma.rs	/^pub enum TransferMode {$/;"	g
Transfer_Completing	usart.rs	/^    Transfer_Completing, \/\/ DMA finished, but not all bytes sent$/;"	e	enum:USARTStateTX
TransmitInterrupt	can.rs	/^    TransmitInterrupt,$/;"	e	enum:CanInterruptMode
Trng	trng.rs	/^impl<'a> Trng<'a> {$/;"	c
Trng	trng.rs	/^impl<'a> hil::entropy::Entropy32<'a> for Trng<'a> {$/;"	c
Trng	trng.rs	/^pub struct Trng<'a> {$/;"	s
TrngIter	trng.rs	/^impl Iterator for TrngIter<'_, '_> {$/;"	c
TrngIter	trng.rs	/^struct TrngIter<'a, 'b: 'a>(&'a Trng<'b>);$/;"	s
TxDMA	spi.rs	/^pub struct TxDMA<'a>(pub &'a dma::Stream<'a, Dma1<'a>>);$/;"	s
TxDMA	usart.rs	/^pub struct TxDMA<'a, DMA: dma::StreamServer<'a>>(pub &'a dma::Stream<'a, DMA>);$/;"	s
USART1	rcc.rs	/^    USART1,$/;"	e	enum:PCLK2
USART1_RX	dma.rs	/^    USART1_RX,$/;"	e	enum:Dma2Peripheral
USART1_TX	dma.rs	/^    USART1_TX,$/;"	e	enum:Dma2Peripheral
USART2	rcc.rs	/^    USART2,$/;"	e	enum:PCLK1
USART2_RX	dma.rs	/^    USART2_RX,$/;"	e	enum:Dma1Peripheral
USART2_TX	dma.rs	/^    USART2_TX,$/;"	e	enum:Dma1Peripheral
USART3	rcc.rs	/^    USART3,$/;"	e	enum:PCLK1
USART3_RX	dma.rs	/^    USART3_RX,$/;"	e	enum:Dma1Peripheral
USART3_TX	dma.rs	/^    USART3_TX,$/;"	e	enum:Dma1Peripheral
USARTStateRX	usart.rs	/^enum USARTStateRX {$/;"	g
USARTStateTX	usart.rs	/^enum USARTStateTX {$/;"	g
Usart	usart.rs	/^impl<'a, DMA: dma::StreamServer<'a>> Usart<'a, DMA> {$/;"	c
Usart	usart.rs	/^impl<'a, DMA: dma::StreamServer<'a>> hil::uart::Configure for Usart<'a, DMA> {$/;"	c
Usart	usart.rs	/^impl<'a, DMA: dma::StreamServer<'a>> hil::uart::Receive<'a> for Usart<'a, DMA> {$/;"	c
Usart	usart.rs	/^impl<'a, DMA: dma::StreamServer<'a>> hil::uart::Transmit<'a> for Usart<'a, DMA> {$/;"	c
Usart	usart.rs	/^impl<'a> Usart<'a, dma::Dma1<'a>> {$/;"	c
Usart	usart.rs	/^impl<'a> Usart<'a, dma::Dma2<'a>> {$/;"	c
Usart	usart.rs	/^impl<'a> dma::StreamClient<'a, dma::Dma1<'a>> for Usart<'a, dma::Dma1<'a>> {$/;"	c
Usart	usart.rs	/^impl<'a> dma::StreamClient<'a, dma::Dma2<'a>> for Usart<'a, dma::Dma2<'a>> {$/;"	c
Usart	usart.rs	/^pub struct Usart<'a, DMA: dma::StreamServer<'a>> {$/;"	s
Usart1	deferred_calls.rs	/^    Usart1 = 1,$/;"	e	enum:DeferredCallTask
Usart2	deferred_calls.rs	/^    Usart2 = 2,$/;"	e	enum:DeferredCallTask
Usart3	deferred_calls.rs	/^    Usart3 = 3,$/;"	e	enum:DeferredCallTask
UsartClock	usart.rs	/^impl ClockInterface for UsartClock<'_> {$/;"	c
UsartClock	usart.rs	/^struct UsartClock<'a>(rcc::PeripheralClock<'a>);$/;"	s
UsartRegisters	usart.rs	/^pub struct UsartRegisters {$/;"	s
UserspaceKernelBoundary	chip.rs	/^    type UserspaceKernelBoundary = cortexm4::syscall::SysCall;$/;"	t	implementation:Stm32f4xx
Word	dma.rs	/^    Word = 0b10,$/;"	e	enum:Size
Writing	i2c.rs	/^    Writing,$/;"	e	enum:I2CStatus
WritingReading	i2c.rs	/^    WritingReading,$/;"	e	enum:I2CStatus
_estack	lib.rs	/^    fn _estack();$/;"	f
_reserved0	rcc.rs	/^    _reserved0: [u8; 4],$/;"	m	struct:RccRegisters
_reserved0	syscfg.rs	/^    _reserved0: [u8; 8],$/;"	m	struct:SyscfgRegisters
_reserved0	tim2.rs	/^    _reserved0: [u8; 4],$/;"	m	struct:Tim2Registers
_reserved1	rcc.rs	/^    _reserved1: [u8; 8],$/;"	m	struct:RccRegisters
_reserved1	tim2.rs	/^    _reserved1: [u8; 4],$/;"	m	struct:Tim2Registers
_reserved2	rcc.rs	/^    _reserved2: [u8; 4],$/;"	m	struct:RccRegisters
_reserved3	rcc.rs	/^    _reserved3: [u8; 8],$/;"	m	struct:RccRegisters
_reserved4	rcc.rs	/^    _reserved4: [u8; 4],$/;"	m	struct:RccRegisters
_reserved5	rcc.rs	/^    _reserved5: [u8; 8],$/;"	m	struct:RccRegisters
_reserved6	rcc.rs	/^    _reserved6: [u8; 8],$/;"	m	struct:RccRegisters
_reseved	fsmc.rs	/^    _reseved: [u8; 228],$/;"	m	struct:FsmcBankRegisters
abort_rx	usart.rs	/^    fn abort_rx(&self, rcode: Result<(), ErrorCode>, error: hil::uart::Error) {$/;"	P	implementation:Usart
abort_transfer	dma.rs	/^    pub fn abort_transfer(&self) -> (Option<&'static mut [u8]>, u32) {$/;"	P	implementation:Stream
abort_tx	usart.rs	/^    fn abort_tx(&self, rcode: Result<(), ErrorCode>) {$/;"	P	implementation:Usart
active_after	spi.rs	/^    active_after: Cell<bool>,$/;"	m	struct:Spi
active_slave	spi.rs	/^    active_slave: OptionalCell<&'a crate::gpio::Pin<'a>>,$/;"	m	struct:Spi
adc	lib.rs	/^pub mod adc;$/;"	n
adc1	chip.rs	/^    pub adc1: crate::adc::Adc<'a>,$/;"	m	struct:Stm32f4xxDefaultPeripherals
address	dma.rs	/^    fn address(&self) -> u32 {$/;"	P	implementation:Dma1Peripheral
address	dma.rs	/^    fn address(&self) -> u32 {$/;"	P	implementation:Dma2Peripheral
address	dma.rs	/^    fn address(&self) -> u32;$/;"	P	interface:StreamPeripheral
afrh	gpio.rs	/^    afrh: ReadWrite<u32, AFRH::Register>,$/;"	m	struct:GpioRegisters
afrl	gpio.rs	/^    afrl: ReadWrite<u32, AFRL::Register>,$/;"	m	struct:GpioRegisters
ahb1enr	rcc.rs	/^    ahb1enr: ReadWrite<u32, AHB1ENR::Register>,$/;"	m	struct:RccRegisters
ahb1lpenr	rcc.rs	/^    ahb1lpenr: ReadWrite<u32, AHB1LPENR::Register>,$/;"	m	struct:RccRegisters
ahb1rstr	rcc.rs	/^    ahb1rstr: ReadWrite<u32, AHB1RSTR::Register>,$/;"	m	struct:RccRegisters
ahb2enr	rcc.rs	/^    ahb2enr: ReadWrite<u32, AHB2ENR::Register>,$/;"	m	struct:RccRegisters
ahb2lpenr	rcc.rs	/^    ahb2lpenr: ReadWrite<u32, AHB2LPENR::Register>,$/;"	m	struct:RccRegisters
ahb2rstr	rcc.rs	/^    ahb2rstr: ReadWrite<u32, AHB2RSTR::Register>,$/;"	m	struct:RccRegisters
ahb3enr	rcc.rs	/^    ahb3enr: ReadWrite<u32, AHB3ENR::Register>,$/;"	m	struct:RccRegisters
ahb3lpenr	rcc.rs	/^    ahb3lpenr: ReadWrite<u32, AHB3LPENR::Register>,$/;"	m	struct:RccRegisters
ahb3rstr	rcc.rs	/^    ahb3rstr: ReadWrite<u32, AHB3RSTR::Register>,$/;"	m	struct:RccRegisters
apb1enr	rcc.rs	/^    apb1enr: ReadWrite<u32, APB1ENR::Register>,$/;"	m	struct:RccRegisters
apb1lpenr	rcc.rs	/^    apb1lpenr: ReadWrite<u32, APB1LPENR::Register>,$/;"	m	struct:RccRegisters
apb1rstr	rcc.rs	/^    apb1rstr: ReadWrite<u32, APB1RSTR::Register>,$/;"	m	struct:RccRegisters
apb2enr	rcc.rs	/^    apb2enr: ReadWrite<u32, APB2ENR::Register>,$/;"	m	struct:RccRegisters
apb2lpenr	rcc.rs	/^    apb2lpenr: ReadWrite<u32, APB2LPENR::Register>,$/;"	m	struct:RccRegisters
apb2rstr	rcc.rs	/^    apb2rstr: ReadWrite<u32, APB2RSTR::Register>,$/;"	m	struct:RccRegisters
arr	tim2.rs	/^    arr: ReadWrite<u32, ARR::Register>,$/;"	m	struct:Tim2Registers
associate_line_gpiopin	exti.rs	/^    pub fn associate_line_gpiopin(&self, lineid: LineId, pin: &'static gpio::Pin<'static>) {$/;"	P	implementation:Exti
atomic	chip.rs	/^    unsafe fn atomic<F, R>(&self, f: F) -> R$/;"	P	implementation:Stm32f4xx
automatic_retransmission	can.rs	/^    automatic_retransmission: Cell<bool>,$/;"	m	struct:Can
automatic_wake_up	can.rs	/^    automatic_wake_up: Cell<bool>,$/;"	m	struct:Can
bank	fsmc.rs	/^    bank: [Option<StaticRef<FsmcBank>>; 4],$/;"	m	struct:Fsmc
bcr1	fsmc.rs	/^    bcr1: ReadWrite<u32, BCR::Register>,$/;"	m	struct:FsmcBankRegisters
bcr2	fsmc.rs	/^    bcr2: ReadWrite<u32, BCR::Register>,$/;"	m	struct:FsmcBankRegisters
bcr3	fsmc.rs	/^    bcr3: ReadWrite<u32, BCR::Register>,$/;"	m	struct:FsmcBankRegisters
bcr4	fsmc.rs	/^    bcr4: ReadWrite<u32, BCR::Register>,$/;"	m	struct:FsmcBankRegisters
bdcr	rcc.rs	/^    bdcr: ReadWrite<u32, BDCR::Register>,$/;"	m	struct:RccRegisters
bit_timing	can.rs	/^    bit_timing: OptionalCell<can::BitTiming>,$/;"	m	struct:Can
brr	usart.rs	/^    brr: ReadWrite<u32, BRR::Register>,$/;"	m	struct:UsartRegisters
bsrr	gpio.rs	/^    bsrr: WriteOnly<u32, BSRR::Register>,$/;"	m	struct:GpioRegisters
btr1	fsmc.rs	/^    btr1: ReadWrite<u32, BTR::Register>,$/;"	m	struct:FsmcBankRegisters
btr2	fsmc.rs	/^    btr2: ReadWrite<u32, BTR::Register>,$/;"	m	struct:FsmcBankRegisters
btr3	fsmc.rs	/^    btr3: ReadWrite<u32, BTR::Register>,$/;"	m	struct:FsmcBankRegisters
btr4	fsmc.rs	/^    btr4: ReadWrite<u32, BTR::Register>,$/;"	m	struct:FsmcBankRegisters
buffer	dma.rs	/^    buffer: TakeCell<'static, [u8]>,$/;"	m	struct:Stream
buffer	fsmc.rs	/^    buffer: TakeCell<'static, [u8]>,$/;"	m	struct:Fsmc
buffer	i2c.rs	/^    buffer: TakeCell<'static, [u8]>,$/;"	m	struct:I2C
bus_width	fsmc.rs	/^    bus_width: Cell<usize>,$/;"	m	struct:Fsmc
bwtr1	fsmc.rs	/^    bwtr1: ReadWrite<u32, BWTR::Register>,$/;"	m	struct:FsmcBankRegisters
bwtr2	fsmc.rs	/^    bwtr2: ReadWrite<u32, BWTR::Register>,$/;"	m	struct:FsmcBankRegisters
bwtr3	fsmc.rs	/^    bwtr3: ReadWrite<u32, BWTR::Register>,$/;"	m	struct:FsmcBankRegisters
bwtr4	fsmc.rs	/^    bwtr4: ReadWrite<u32, BWTR::Register>,$/;"	m	struct:FsmcBankRegisters
can	lib.rs	/^pub mod can;$/;"	n
can_state	can.rs	/^    can_state: Cell<CanState>,$/;"	m	struct:Can
cancel	trng.rs	/^    fn cancel(&self) -> Result<(), ErrorCode> {$/;"	P	implementation:Trng
ccer	tim2.rs	/^    ccer: ReadWrite<u32, CCER::Register>,$/;"	m	struct:Tim2Registers
ccmr1_output	tim2.rs	/^    ccmr1_output: ReadWrite<u32, CCMR1_Output::Register>,$/;"	m	struct:Tim2Registers
ccmr2_output	tim2.rs	/^    ccmr2_output: ReadWrite<u32, CCMR2_Output::Register>,$/;"	m	struct:Tim2Registers
ccr	adc.rs	/^    ccr: ReadWrite<u32, CCR::Register>,$/;"	m	struct:AdcCommonRegisters
ccr	i2c.rs	/^    ccr: ReadWrite<u32, CCR::Register>,$/;"	m	struct:I2CRegisters
ccr1	tim2.rs	/^    ccr1: ReadWrite<u32, CCR1::Register>,$/;"	m	struct:Tim2Registers
ccr2	tim2.rs	/^    ccr2: ReadWrite<u32, CCR2::Register>,$/;"	m	struct:Tim2Registers
ccr3	tim2.rs	/^    ccr3: ReadWrite<u32, CCR3::Register>,$/;"	m	struct:Tim2Registers
ccr4	tim2.rs	/^    ccr4: ReadWrite<u32, CCR4::Register>,$/;"	m	struct:Tim2Registers
cfgr	rcc.rs	/^    cfgr: ReadWrite<u32, CFGR::Register>,$/;"	m	struct:RccRegisters
channel_id	dma.rs	/^    fn channel_id(&self) -> ChannelId {$/;"	P	implementation:Dma1Peripheral
channel_id	dma.rs	/^    fn channel_id(&self) -> ChannelId {$/;"	P	implementation:Dma2Peripheral
channel_id	dma.rs	/^    fn channel_id(&self) -> ChannelId;$/;"	P	interface:StreamPeripheral
check_apb1_frequency_limit	clk/clocks.rs	/^    fn check_apb1_frequency_limit(&self, sys_clk_frequency_mhz: usize) -> bool {$/;"	P	implementation:Clocks
check_apb2_frequency_limit	clk/clocks.rs	/^    fn check_apb2_frequency_limit(&self, sys_clk_frequency_mhz: usize) -> bool {$/;"	P	implementation:Clocks
chip	lib.rs	/^pub mod chip;$/;"	n
cir	rcc.rs	/^    cir: ReadWrite<u32, CIR::Register>,$/;"	m	struct:RccRegisters
ckgatenr	rcc.rs	/^    ckgatenr: ReadWrite<u32, CKGATENR::Register>,$/;"	m	struct:RccRegisters
clear	gpio.rs	/^    fn clear(&self) {$/;"	P	implementation:Pin
clear_pending	exti.rs	/^    pub fn clear_pending(&self, lineid: LineId) {$/;"	P	implementation:Exti
clear_transfer_complete_flag	dma.rs	/^    fn clear_transfer_complete_flag(&self) {$/;"	P	implementation:Stream
clear_transmit_complete	usart.rs	/^    fn clear_transmit_complete(&self) {$/;"	P	implementation:Usart
client	adc.rs	/^    client: OptionalCell<&'static dyn hil::adc::Client>,$/;"	m	struct:Adc
client	dma.rs	/^    client: OptionalCell<&'a dyn StreamClient<'a, DMA>>,$/;"	m	struct:Stream
client	fsmc.rs	/^    client: OptionalCell<&'static dyn Client>,$/;"	m	struct:Fsmc
client	gpio.rs	/^    client: OptionalCell<&'a dyn hil::gpio::Client>,$/;"	m	struct:Pin
client	tim2.rs	/^    client: OptionalCell<&'a dyn AlarmClient>,$/;"	m	struct:Tim2
client	trng.rs	/^    client: OptionalCell<&'a dyn hil::entropy::Client32>,$/;"	m	struct:Trng
clk	lib.rs	/^mod clk;$/;"	n
clock	adc.rs	/^    clock: AdcClock<'a>,$/;"	m	struct:Adc
clock	can.rs	/^    clock: CanClock<'a>,$/;"	m	struct:Can
clock	dma.rs	/^    clock: DmaClock<'a>,$/;"	m	struct:Dma1
clock	dma.rs	/^    clock: DmaClock<'a>,$/;"	m	struct:Dma2
clock	exti.rs	/^    clock: ExtiClock<'a>,$/;"	m	struct:Exti
clock	fsmc.rs	/^    clock: FsmcClock<'a>,$/;"	m	struct:Fsmc
clock	gpio.rs	/^    clock: PortClock<'a>,$/;"	m	struct:Port
clock	i2c.rs	/^    clock: I2CClock<'a>,$/;"	m	struct:I2C
clock	rcc.rs	/^    pub clock: PeripheralClockType,$/;"	m	struct:PeripheralClock
clock	spi.rs	/^    clock: SpiClock<'a>,$/;"	m	struct:Spi
clock	syscfg.rs	/^    clock: SyscfgClock<'a>,$/;"	m	struct:Syscfg
clock	tim2.rs	/^    clock: Tim2Clock<'a>,$/;"	m	struct:Tim2
clock	trng.rs	/^    clock: RngClock<'a>,$/;"	m	struct:Trng
clock	usart.rs	/^    clock: UsartClock<'a>,$/;"	m	struct:Usart
clocks	chip.rs	/^    pub clocks: crate::clk::clocks::Clocks<'a>,$/;"	m	struct:Stm32f4xxDefaultPeripherals
clocks	clk/mod.rs	/^pub mod clocks;$/;"	n
cmpcr	syscfg.rs	/^    cmpcr: ReadOnly<u32, CMPCR::Register>,$/;"	m	struct:SyscfgRegisters
cnt	tim2.rs	/^    cnt: ReadWrite<u32, CNT::Register>,$/;"	m	struct:Tim2Registers
common_registers	adc.rs	/^    common_registers: StaticRef<AdcCommonRegisters>,$/;"	m	struct:Adc
compute_plln	clk/pll.rs	/^    fn compute_plln(desired_frequency_mhz: usize, pllp: PLLP) -> usize {$/;"	P	implementation:Pll
compute_pllp	clk/pll.rs	/^    fn compute_pllp(desired_frequency_mhz: usize) -> PLLP {$/;"	P	implementation:Pll
compute_pllq	clk/pll.rs	/^    fn compute_pllq(vco_output_frequency_mhz: usize) -> PLLQ {$/;"	P	implementation:Pll
config_filter	can.rs	/^    pub fn config_filter(&self, filter_info: can::FilterParameters, enable: bool) {$/;"	P	implementation:Can
configuration	gpio.rs	/^    fn configuration(&self) -> hil::gpio::Configuration {$/;"	P	implementation:Pin
configure	usart.rs	/^    fn configure(&self, params: hil::uart::Parameters) -> Result<(), ErrorCode> {$/;"	P	implementation:Usart
configure_interrupt	syscfg.rs	/^    pub fn configure_interrupt(&self, pinid: gpio::PinId) {$/;"	P	implementation:Syscfg
configure_rng_clock	rcc.rs	/^    fn configure_rng_clock(&self) {$/;"	P	implementation:Rcc
configure_rng_clock	rcc.rs	/^    pub fn configure_rng_clock(&self) {$/;"	P	implementation:PeripheralClock
controller_client	can.rs	/^    controller_client: OptionalCell<&'static dyn can::ControllerClient>,$/;"	m	struct:Can
cr	rcc.rs	/^    cr: ReadWrite<u32, CR::Register>,$/;"	m	struct:RccRegisters
cr	trng.rs	/^    cr: ReadWrite<u32, Control::Register>,$/;"	m	struct:RngRegisters
cr1	adc.rs	/^    cr1: ReadWrite<u32, CR1::Register>,$/;"	m	struct:AdcRegisters
cr1	i2c.rs	/^    cr1: ReadWrite<u32, CR1::Register>,$/;"	m	struct:I2CRegisters
cr1	spi.rs	/^    cr1: ReadWrite<u32, CR1::Register>,$/;"	m	struct:SpiRegisters
cr1	tim2.rs	/^    cr1: ReadWrite<u32, CR1::Register>,$/;"	m	struct:Tim2Registers
cr1	usart.rs	/^    cr1: ReadWrite<u32, CR1::Register>,$/;"	m	struct:UsartRegisters
cr2	adc.rs	/^    cr2: ReadWrite<u32, CR2::Register>,$/;"	m	struct:AdcRegisters
cr2	i2c.rs	/^    cr2: ReadWrite<u32, CR2::Register>,$/;"	m	struct:I2CRegisters
cr2	spi.rs	/^    cr2: ReadWrite<u32, CR2::Register>,$/;"	m	struct:SpiRegisters
cr2	tim2.rs	/^    cr2: ReadWrite<u32, CR2::Register>,$/;"	m	struct:Tim2Registers
cr2	usart.rs	/^    cr2: ReadWrite<u32, CR2::Register>,$/;"	m	struct:UsartRegisters
cr3	usart.rs	/^    cr3: ReadWrite<u32, CR3::Register>,$/;"	m	struct:UsartRegisters
crcpr	spi.rs	/^    crcpr: ReadWrite<u32>,$/;"	m	struct:SpiRegisters
csr	adc.rs	/^    csr: ReadOnly<u32, CSR::Register>,$/;"	m	struct:AdcCommonRegisters
csr	rcc.rs	/^    csr: ReadWrite<u32, CSR::Register>,$/;"	m	struct:RccRegisters
data	trng.rs	/^    data: ReadOnly<u32, Data::Register>,$/;"	m	struct:RngRegisters
data_width	dma.rs	/^    fn data_width(&self) -> (Msize, Psize) {$/;"	P	implementation:Dma1Peripheral
data_width	dma.rs	/^    fn data_width(&self) -> (Msize, Psize) {$/;"	P	implementation:Dma2Peripheral
data_width	dma.rs	/^    fn data_width(&self) -> (Msize, Psize);$/;"	P	interface:StreamPeripheral
dbg	lib.rs	/^pub mod dbg;$/;"	n
dbgmcu_apb1_fz	dbg.rs	/^    dbgmcu_apb1_fz: ReadWrite<u32, DBGMCU_APB1_FZ::Register>,$/;"	m	struct:DbgRegisters
dbgmcu_apb2_fz	dbg.rs	/^    dbgmcu_apb2_fz: ReadWrite<u32, DBGMCU_APB2_FZ::Register>,$/;"	m	struct:DbgRegisters
dbgmcu_cr	dbg.rs	/^    dbgmcu_cr: ReadWrite<u32, DBGMCU_CR::Register>,$/;"	m	struct:DbgRegisters
dbgmcu_idcode	dbg.rs	/^    dbgmcu_idcode: ReadOnly<u32, DBGMCU_IDCODE::Register>,$/;"	m	struct:DbgRegisters
dckcfgr	rcc.rs	/^    dckcfgr: ReadWrite<u32, DCKCFGR::Register>,$/;"	m	struct:RccRegisters
dckcfgr2	rcc.rs	/^    dckcfgr2: ReadWrite<u32, DCKCFGR2::Register>,$/;"	m	struct:RccRegisters
dcr	tim2.rs	/^    dcr: ReadWrite<u32, DCR::Register>,$/;"	m	struct:Tim2Registers
deactivate_to_low_power	gpio.rs	/^    fn deactivate_to_low_power(&self) {$/;"	P	implementation:Pin
declare_gpio_pins	gpio.rs	/^macro_rules! declare_gpio_pins {$/;"	M
deferred_action	can.rs	/^    deferred_action: OptionalCell<AsyncAction>,$/;"	m	struct:Can
deferred_calls	lib.rs	/^pub mod deferred_calls;$/;"	n
deselect_falling_trigger	exti.rs	/^    pub fn deselect_falling_trigger(&self, lineid: LineId) {$/;"	P	implementation:Exti
deselect_rising_trigger	exti.rs	/^    pub fn deselect_rising_trigger(&self, lineid: LineId) {$/;"	P	implementation:Exti
dier	tim2.rs	/^    dier: ReadWrite<u32, DIER::Register>,$/;"	m	struct:Tim2Registers
direction	dma.rs	/^    fn direction(&self) -> Direction {$/;"	P	implementation:Dma1Peripheral
direction	dma.rs	/^    fn direction(&self) -> Direction {$/;"	P	implementation:Dma2Peripheral
direction	dma.rs	/^    fn direction(&self) -> Direction;$/;"	P	interface:StreamPeripheral
disable	adc.rs	/^    fn disable(&self) {$/;"	P	implementation:AdcClock
disable	can.rs	/^    fn disable(&self) -> Result<(), kernel::ErrorCode> {$/;"	P	implementation:Can
disable	can.rs	/^    fn disable(&self) {$/;"	P	implementation:CanClock
disable	clk/hsi.rs	/^    pub fn disable(&self) -> Result<(), ErrorCode> {$/;"	P	implementation:Hsi
disable	clk/pll.rs	/^    pub fn disable(&self) -> Result<(), ErrorCode> {$/;"	P	implementation:Pll
disable	dma.rs	/^    fn disable(&self) {$/;"	P	implementation:DmaClock
disable	dma.rs	/^    fn disable(&self) {$/;"	P	implementation:Stream
disable	exti.rs	/^    fn disable(&self) {$/;"	P	implementation:ExtiClock
disable	fsmc.rs	/^    fn disable(&self) {$/;"	P	implementation:FsmcClock
disable	fsmc.rs	/^    pub fn disable(&self) {$/;"	P	implementation:Fsmc
disable	gpio.rs	/^    fn disable(&self) {$/;"	P	implementation:PortClock
disable	i2c.rs	/^    fn disable(&self) {$/;"	P	implementation:I2C
disable	i2c.rs	/^    fn disable(&self) {$/;"	P	implementation:I2CClock
disable	rcc.rs	/^    fn disable(&self) {$/;"	P	implementation:PeripheralClock
disable	spi.rs	/^    fn disable(&self) {$/;"	P	implementation:SpiClock
disable	syscfg.rs	/^    fn disable(&self) {$/;"	P	implementation:SyscfgClock
disable	tim2.rs	/^    fn disable(&self) {$/;"	P	implementation:Tim2Clock
disable	trng.rs	/^    fn disable(&self) {$/;"	P	implementation:RngClock
disable	usart.rs	/^    fn disable(&self) {$/;"	P	implementation:UsartClock
disable_adc1_clock	rcc.rs	/^    fn disable_adc1_clock(&self) {$/;"	P	implementation:Rcc
disable_can1_clock	rcc.rs	/^    fn disable_can1_clock(&self) {$/;"	P	implementation:Rcc
disable_clock	adc.rs	/^    pub fn disable_clock(&self) {$/;"	P	implementation:Adc
disable_clock	can.rs	/^    pub fn disable_clock(&self) {$/;"	P	implementation:Can
disable_clock	dma.rs	/^    pub fn disable_clock(&self) {$/;"	P	implementation:Dma1
disable_clock	dma.rs	/^    pub fn disable_clock(&self) {$/;"	P	implementation:Dma2
disable_clock	exti.rs	/^    pub fn disable_clock(&self) {$/;"	P	implementation:Exti
disable_clock	fsmc.rs	/^    pub fn disable_clock(&self) {$/;"	P	implementation:Fsmc
disable_clock	gpio.rs	/^    pub fn disable_clock(&self) {$/;"	P	implementation:Port
disable_clock	i2c.rs	/^    pub fn disable_clock(&self) {$/;"	P	implementation:I2C
disable_clock	spi.rs	/^    pub fn disable_clock(&self) {$/;"	P	implementation:Spi
disable_clock	syscfg.rs	/^    pub fn disable_clock(&self) {$/;"	P	implementation:Syscfg
disable_clock	tim2.rs	/^    pub fn disable_clock(&self) {$/;"	P	implementation:Tim2
disable_clock	trng.rs	/^    pub fn disable_clock(&self) {$/;"	P	implementation:Trng
disable_clock	usart.rs	/^    pub fn disable_clock(&self) {$/;"	P	implementation:Usart
disable_dma1_clock	rcc.rs	/^    fn disable_dma1_clock(&self) {$/;"	P	implementation:Rcc
disable_dma2_clock	rcc.rs	/^    fn disable_dma2_clock(&self) {$/;"	P	implementation:Rcc
disable_fmc_clock	rcc.rs	/^    fn disable_fmc_clock(&self) {$/;"	P	implementation:Rcc
disable_gpioa_clock	rcc.rs	/^    fn disable_gpioa_clock(&self) {$/;"	P	implementation:Rcc
disable_gpiob_clock	rcc.rs	/^    fn disable_gpiob_clock(&self) {$/;"	P	implementation:Rcc
disable_gpioc_clock	rcc.rs	/^    fn disable_gpioc_clock(&self) {$/;"	P	implementation:Rcc
disable_gpiod_clock	rcc.rs	/^    fn disable_gpiod_clock(&self) {$/;"	P	implementation:Rcc
disable_gpioe_clock	rcc.rs	/^    fn disable_gpioe_clock(&self) {$/;"	P	implementation:Rcc
disable_gpiof_clock	rcc.rs	/^    fn disable_gpiof_clock(&self) {$/;"	P	implementation:Rcc
disable_gpiog_clock	rcc.rs	/^    fn disable_gpiog_clock(&self) {$/;"	P	implementation:Rcc
disable_gpioh_clock	rcc.rs	/^    fn disable_gpioh_clock(&self) {$/;"	P	implementation:Rcc
disable_hsi_clock	rcc.rs	/^    pub(crate) fn disable_hsi_clock(&self) {$/;"	P	implementation:Rcc
disable_i2c1_clock	rcc.rs	/^    fn disable_i2c1_clock(&self) {$/;"	P	implementation:Rcc
disable_input	gpio.rs	/^    fn disable_input(&self) -> hil::gpio::Configuration {$/;"	P	implementation:Pin
disable_interrupt	dma.rs	/^    fn disable_interrupt(&self) {$/;"	P	implementation:Stream
disable_interrupts	gpio.rs	/^    fn disable_interrupts(&self) {$/;"	P	implementation:Pin
disable_irq	can.rs	/^    pub fn disable_irq(&self, interrupt: CanInterruptMode) {$/;"	P	implementation:Can
disable_irqs	can.rs	/^    pub fn disable_irqs(&self) {$/;"	P	implementation:Can
disable_otgfs_clock	rcc.rs	/^    fn disable_otgfs_clock(&self) {$/;"	P	implementation:Rcc
disable_output	gpio.rs	/^    fn disable_output(&self) -> hil::gpio::Configuration {$/;"	P	implementation:Pin
disable_pll_clock	rcc.rs	/^    pub(crate) fn disable_pll_clock(&self) {$/;"	P	implementation:Rcc
disable_rng_clock	rcc.rs	/^    fn disable_rng_clock(&self) {$/;"	P	implementation:Rcc
disable_rx	spi.rs	/^    fn disable_rx(&self) {$/;"	P	implementation:Spi
disable_rx	usart.rs	/^    fn disable_rx(&self) {$/;"	P	implementation:Usart
disable_spi3_clock	rcc.rs	/^    fn disable_spi3_clock(&self) {$/;"	P	implementation:Rcc
disable_syscfg_clock	rcc.rs	/^    fn disable_syscfg_clock(&self) {$/;"	P	implementation:Rcc
disable_tim2_clock	rcc.rs	/^    fn disable_tim2_clock(&self) {$/;"	P	implementation:Rcc
disable_tim2_counter	dbg.rs	/^    pub fn disable_tim2_counter(&self) {$/;"	P	implementation:Dbg
disable_transmit_complete_interrupt	usart.rs	/^    fn disable_transmit_complete_interrupt(&self) {$/;"	P	implementation:Usart
disable_tx	spi.rs	/^    fn disable_tx(&self) {$/;"	P	implementation:Spi
disable_tx	usart.rs	/^    fn disable_tx(&self) {$/;"	P	implementation:Usart
disable_usart1_clock	rcc.rs	/^    fn disable_usart1_clock(&self) {$/;"	P	implementation:Rcc
disable_usart2_clock	rcc.rs	/^    fn disable_usart2_clock(&self) {$/;"	P	implementation:Rcc
disable_usart3_clock	rcc.rs	/^    fn disable_usart3_clock(&self) {$/;"	P	implementation:Rcc
disarm	tim2.rs	/^    fn disarm(&self) -> Result<(), ErrorCode> {$/;"	P	implementation:Tim2
dma	dma.rs	/^    dma: &'a DMA,$/;"	m	struct:Stream
dma	lib.rs	/^pub mod dma;$/;"	n
dma1_streams	chip.rs	/^    pub dma1_streams: [crate::dma::Stream<'a, dma::Dma1<'a>>; 8],$/;"	m	struct:Stm32f4xxDefaultPeripherals
dma2_streams	chip.rs	/^    pub dma2_streams: [crate::dma::Stream<'a, dma::Dma2<'a>>; 8],$/;"	m	struct:Stm32f4xxDefaultPeripherals
dma_len	spi.rs	/^    dma_len: Cell<usize>,$/;"	m	struct:Spi
dmar	tim2.rs	/^    dmar: ReadWrite<u32>,$/;"	m	struct:Tim2Registers
do_transfer	dma.rs	/^    pub fn do_transfer(&self, buf: &'static mut [u8], len: usize) {$/;"	P	implementation:Stream
dr	adc.rs	/^    dr: ReadOnly<u32, DR::Register>,$/;"	m	struct:AdcRegisters
dr	i2c.rs	/^    dr: ReadWrite<u32, DR::Register>,$/;"	m	struct:I2CRegisters
dr	spi.rs	/^    dr: ReadWrite<u32, DR::Register>,$/;"	m	struct:SpiRegisters
dr	usart.rs	/^    dr: ReadWrite<u32>,$/;"	m	struct:UsartRegisters
egr	tim2.rs	/^    egr: WriteOnly<u32, EGR::Register>,$/;"	m	struct:Tim2Registers
emr	exti.rs	/^    emr: ReadWrite<u32, EMR::Register>,$/;"	m	struct:ExtiRegisters
enable	adc.rs	/^    fn enable(&self) {$/;"	P	implementation:AdcClock
enable	adc.rs	/^    pub fn enable(&self) {$/;"	P	implementation:Adc
enable	can.rs	/^    fn enable(&self) -> Result<(), kernel::ErrorCode> {$/;"	P	implementation:Can
enable	can.rs	/^    fn enable(&self) {$/;"	P	implementation:CanClock
enable	can.rs	/^    pub fn enable(&self) -> Result<(), kernel::ErrorCode> {$/;"	P	implementation:Can
enable	clk/hsi.rs	/^    pub fn enable(&self) -> Result<(), ErrorCode> {$/;"	P	implementation:Hsi
enable	clk/pll.rs	/^    pub fn enable(&self) -> Result<(), ErrorCode> {$/;"	P	implementation:Pll
enable	dma.rs	/^    fn enable(&self) {$/;"	P	implementation:DmaClock
enable	dma.rs	/^    fn enable(&self) {$/;"	P	implementation:Stream
enable	exti.rs	/^    fn enable(&self) {$/;"	P	implementation:ExtiClock
enable	fsmc.rs	/^    fn enable(&self) {$/;"	P	implementation:FsmcClock
enable	fsmc.rs	/^    pub fn enable(&self) {$/;"	P	implementation:Fsmc
enable	gpio.rs	/^    fn enable(&self) {$/;"	P	implementation:PortClock
enable	i2c.rs	/^    fn enable(&self) {$/;"	P	implementation:I2C
enable	i2c.rs	/^    fn enable(&self) {$/;"	P	implementation:I2CClock
enable	rcc.rs	/^    fn enable(&self) {$/;"	P	implementation:PeripheralClock
enable	spi.rs	/^    fn enable(&self) {$/;"	P	implementation:SpiClock
enable	syscfg.rs	/^    fn enable(&self) {$/;"	P	implementation:SyscfgClock
enable	tim2.rs	/^    fn enable(&self) {$/;"	P	implementation:Tim2Clock
enable	trng.rs	/^    fn enable(&self) {$/;"	P	implementation:RngClock
enable	usart.rs	/^    fn enable(&self) {$/;"	P	implementation:UsartClock
enable_adc1_clock	rcc.rs	/^    fn enable_adc1_clock(&self) {$/;"	P	implementation:Rcc
enable_can1_clock	rcc.rs	/^    fn enable_can1_clock(&self) {$/;"	P	implementation:Rcc
enable_clock	adc.rs	/^    pub fn enable_clock(&self) {$/;"	P	implementation:Adc
enable_clock	can.rs	/^    pub fn enable_clock(&self) {$/;"	P	implementation:Can
enable_clock	dma.rs	/^    pub fn enable_clock(&self) {$/;"	P	implementation:Dma1
enable_clock	dma.rs	/^    pub fn enable_clock(&self) {$/;"	P	implementation:Dma2
enable_clock	exti.rs	/^    pub fn enable_clock(&self) {$/;"	P	implementation:Exti
enable_clock	fsmc.rs	/^    pub fn enable_clock(&self) {$/;"	P	implementation:Fsmc
enable_clock	gpio.rs	/^    pub fn enable_clock(&self) {$/;"	P	implementation:Port
enable_clock	i2c.rs	/^    pub fn enable_clock(&self) {$/;"	P	implementation:I2C
enable_clock	spi.rs	/^    pub fn enable_clock(&self) {$/;"	P	implementation:Spi
enable_clock	syscfg.rs	/^    pub fn enable_clock(&self) {$/;"	P	implementation:Syscfg
enable_clock	tim2.rs	/^    pub fn enable_clock(&self) {$/;"	P	implementation:Tim2
enable_clock	trng.rs	/^    pub fn enable_clock(&self) {$/;"	P	implementation:Trng
enable_clock	usart.rs	/^    pub fn enable_clock(&self) {$/;"	P	implementation:Usart
enable_dma1_clock	rcc.rs	/^    fn enable_dma1_clock(&self) {$/;"	P	implementation:Rcc
enable_dma2_clock	rcc.rs	/^    fn enable_dma2_clock(&self) {$/;"	P	implementation:Rcc
enable_filter_config	can.rs	/^    pub fn enable_filter_config(&self) {$/;"	P	implementation:Can
enable_fmc_clock	rcc.rs	/^    fn enable_fmc_clock(&self) {$/;"	P	implementation:Rcc
enable_gpioa_clock	rcc.rs	/^    fn enable_gpioa_clock(&self) {$/;"	P	implementation:Rcc
enable_gpiob_clock	rcc.rs	/^    fn enable_gpiob_clock(&self) {$/;"	P	implementation:Rcc
enable_gpioc_clock	rcc.rs	/^    fn enable_gpioc_clock(&self) {$/;"	P	implementation:Rcc
enable_gpiod_clock	rcc.rs	/^    fn enable_gpiod_clock(&self) {$/;"	P	implementation:Rcc
enable_gpioe_clock	rcc.rs	/^    fn enable_gpioe_clock(&self) {$/;"	P	implementation:Rcc
enable_gpiof_clock	rcc.rs	/^    fn enable_gpiof_clock(&self) {$/;"	P	implementation:Rcc
enable_gpiog_clock	rcc.rs	/^    fn enable_gpiog_clock(&self) {$/;"	P	implementation:Rcc
enable_gpioh_clock	rcc.rs	/^    fn enable_gpioh_clock(&self) {$/;"	P	implementation:Rcc
enable_hsi_clock	rcc.rs	/^    pub(crate) fn enable_hsi_clock(&self) {$/;"	P	implementation:Rcc
enable_i2c1_clock	rcc.rs	/^    fn enable_i2c1_clock(&self) {$/;"	P	implementation:Rcc
enable_interrupt	gpio.rs	/^    pub unsafe fn enable_interrupt(&'static self) {$/;"	P	implementation:Pin
enable_interrupts	gpio.rs	/^    fn enable_interrupts(&self, mode: hil::gpio::InterruptEdge) {$/;"	P	implementation:Pin
enable_irq	can.rs	/^    pub fn enable_irq(&self, interrupt: CanInterruptMode) {$/;"	P	implementation:Can
enable_irqs	can.rs	/^    pub fn enable_irqs(&self) {$/;"	P	implementation:Can
enable_otgfs_clock	rcc.rs	/^    fn enable_otgfs_clock(&self) {$/;"	P	implementation:Rcc
enable_pll_clock	rcc.rs	/^    pub(crate) fn enable_pll_clock(&self) {$/;"	P	implementation:Rcc
enable_rng_clock	rcc.rs	/^    fn enable_rng_clock(&self) {$/;"	P	implementation:Rcc
enable_rx	spi.rs	/^    fn enable_rx(&self) {$/;"	P	implementation:Spi
enable_rx	usart.rs	/^    fn enable_rx(&self) {$/;"	P	implementation:Usart
enable_spi3_clock	rcc.rs	/^    fn enable_spi3_clock(&self) {$/;"	P	implementation:Rcc
enable_syscfg_clock	rcc.rs	/^    fn enable_syscfg_clock(&self) {$/;"	P	implementation:Rcc
enable_temperature	adc.rs	/^    pub fn enable_temperature(&self) {$/;"	P	implementation:Adc
enable_tim2_clock	rcc.rs	/^    fn enable_tim2_clock(&self) {$/;"	P	implementation:Rcc
enable_transmit_complete_interrupt	usart.rs	/^    fn enable_transmit_complete_interrupt(&self) {$/;"	P	implementation:Usart
enable_tx	spi.rs	/^    fn enable_tx(&self) {$/;"	P	implementation:Spi
enable_tx	usart.rs	/^    fn enable_tx(&self) {$/;"	P	implementation:Usart
enable_usart1_clock	rcc.rs	/^    fn enable_usart1_clock(&self) {$/;"	P	implementation:Rcc
enable_usart2_clock	rcc.rs	/^    fn enable_usart2_clock(&self) {$/;"	P	implementation:Rcc
enable_usart3_clock	rcc.rs	/^    fn enable_usart3_clock(&self) {$/;"	P	implementation:Rcc
enter_normal_mode	can.rs	/^    pub fn enter_normal_mode(&self) -> Result<(), kernel::ErrorCode> {$/;"	P	implementation:Can
enter_sleep_mode	can.rs	/^    pub fn enter_sleep_mode(&self) {$/;"	P	implementation:Can
error_interrupt_counter	can.rs	/^    error_interrupt_counter: Cell<u32>,$/;"	m	struct:Can
exti	chip.rs	/^    pub exti: &'a crate::exti::Exti<'a>,$/;"	m	struct:Stm32f4xxDefaultPeripherals
exti	gpio.rs	/^    exti: &'a exti::Exti<'a>,$/;"	m	struct:Pin
exti	lib.rs	/^pub mod exti;$/;"	n
exti_lineid	gpio.rs	/^    exti_lineid: OptionalCell<exti::LineId>,$/;"	m	struct:Pin
exticr1	syscfg.rs	/^    exticr1: ReadWrite<u32, EXTICR1::Register>,$/;"	m	struct:SyscfgRegisters
exticr2	syscfg.rs	/^    exticr2: ReadWrite<u32, EXTICR2::Register>,$/;"	m	struct:SyscfgRegisters
exticr3	syscfg.rs	/^    exticr3: ReadWrite<u32, EXTICR3::Register>,$/;"	m	struct:SyscfgRegisters
exticr4	syscfg.rs	/^    exticr4: ReadWrite<u32, EXTICR4::Register>,$/;"	m	struct:SyscfgRegisters
failed_messages	can.rs	/^    failed_messages: Cell<u32>,$/;"	m	struct:Can
fifo0_interrupt_counter	can.rs	/^    fifo0_interrupt_counter: Cell<u32>,$/;"	m	struct:Can
fifo1_interrupt_counter	can.rs	/^    fifo1_interrupt_counter: Cell<u32>,$/;"	m	struct:Can
find_empty_mailbox	can.rs	/^    pub fn find_empty_mailbox(&self) -> Option<usize> {$/;"	P	implementation:Can
flash	chip.rs	/^    pub flash: crate::flash::Flash,$/;"	m	struct:Stm32f4xxDefaultPeripherals
flash	clk/clocks.rs	/^    flash: OptionalCell<&'a Flash>,$/;"	m	struct:Clocks
flash	lib.rs	/^pub mod flash;$/;"	n
floating_state	gpio.rs	/^    fn floating_state(&self) -> hil::gpio::FloatingState {$/;"	P	implementation:Pin
fltr	i2c.rs	/^    fltr: ReadWrite<u32, FLTR::Register>,$/;"	m	struct:I2CRegisters
frequency	clk/pll.rs	/^    frequency: OptionalCell<usize>,$/;"	m	struct:Pll
from	can.rs	/^    fn from(state: CanState) -> Self {$/;"	P	implementation:State
from	dma.rs	/^    fn from(pid: Dma1Peripheral) -> StreamId {$/;"	P	implementation:StreamId
from	dma.rs	/^    fn from(pid: Dma2Peripheral) -> StreamId {$/;"	P	implementation:StreamId
from	rcc.rs	/^    fn from(item: AHBPrescaler) -> usize {$/;"	P	implementation:usize
from	rcc.rs	/^    fn from(item: APBPrescaler) -> Self {$/;"	P	implementation:usize
fsmc	chip.rs	/^    pub fsmc: crate::fsmc::Fsmc<'a>,$/;"	m	struct:Stm32f4xxDefaultPeripherals
fsmc	lib.rs	/^pub mod fsmc;$/;"	n
ftsr	exti.rs	/^    ftsr: ReadWrite<u32, FTSR::Register>,$/;"	m	struct:ExtiRegisters
get	trng.rs	/^    fn get(&self) -> Result<(), ErrorCode> {$/;"	P	implementation:Trng
get_address_dr	spi.rs	/^pub(crate) fn get_address_dr(regs: StaticRef<SpiRegisters>) -> u32 {$/;"	f
get_address_dr	usart.rs	/^pub(crate) fn get_address_dr(regs: StaticRef<UsartRegisters>) -> u32 {$/;"	f
get_ahb_frequency	clk/clocks.rs	/^    pub fn get_ahb_frequency(&self) -> usize {$/;"	P	implementation:Clocks
get_ahb_prescaler	clk/clocks.rs	/^    pub fn get_ahb_prescaler(&self) -> AHBPrescaler {$/;"	P	implementation:Clocks
get_ahb_prescaler	rcc.rs	/^    pub(crate) fn get_ahb_prescaler(&self) -> AHBPrescaler {$/;"	P	implementation:Rcc
get_alarm	tim2.rs	/^    fn get_alarm(&self) -> Self::Ticks {$/;"	P	implementation:Tim2
get_apb1_frequency	clk/clocks.rs	/^    pub fn get_apb1_frequency(&self) -> usize {$/;"	P	implementation:Clocks
get_apb1_prescaler	clk/clocks.rs	/^    pub fn get_apb1_prescaler(&self) -> APBPrescaler {$/;"	P	implementation:Clocks
get_apb1_prescaler	rcc.rs	/^    pub(crate) fn get_apb1_prescaler(&self) -> APBPrescaler {$/;"	P	implementation:Rcc
get_apb2_frequency	clk/clocks.rs	/^    pub fn get_apb2_frequency(&self) -> usize {$/;"	P	implementation:Clocks
get_apb2_prescaler	clk/clocks.rs	/^    pub fn get_apb2_prescaler(&self) -> APBPrescaler {$/;"	P	implementation:Clocks
get_apb2_prescaler	rcc.rs	/^    pub(crate) fn get_apb2_prescaler(&self) -> APBPrescaler {$/;"	P	implementation:Rcc
get_automatic_retransmission	can.rs	/^    fn get_automatic_retransmission(&self) -> Result<bool, kernel::ErrorCode> {$/;"	P	implementation:Can
get_bit_timing	can.rs	/^    fn get_bit_timing(&self) -> Result<can::BitTiming, kernel::ErrorCode> {$/;"	P	implementation:Can
get_data_items	dma.rs	/^    fn get_data_items(&self) -> u32 {$/;"	P	implementation:Stream
get_exticrid_from_port_num	syscfg.rs	/^    fn get_exticrid_from_port_num(&self, port_num: u8) -> ExtiCrId {$/;"	P	implementation:Syscfg
get_frequency	clk/hsi.rs	/^    pub fn get_frequency(&self) -> Option<usize> {$/;"	P	implementation:Hsi
get_frequency	clk/pll.rs	/^    pub fn get_frequency(&self) -> Option<usize> {$/;"	P	implementation:Pll
get_frequency_pll48	clk/pll.rs	/^    pub fn get_frequency_pll48(&self) -> Option<usize> {$/;"	P	implementation:Pll
get_latency	flash.rs	/^    pub fn get_latency(&self) -> FlashLatency {$/;"	P	implementation:Flash
get_mode	gpio.rs	/^    pub fn get_mode(&self) -> Mode {$/;"	P	implementation:Pin
get_number_wait_cycles_based_on_frequency	flash.rs	/^    fn get_number_wait_cycles_based_on_frequency(&self, frequency_mhz: usize) -> FlashLatency {$/;"	P	implementation:Flash
get_operation_mode	can.rs	/^    fn get_operation_mode(&self) -> Result<can::OperationMode, kernel::ErrorCode> {$/;"	P	implementation:Can
get_phase	spi.rs	/^    fn get_phase(&self) -> ClockPhase {$/;"	P	implementation:Spi
get_pin	gpio.rs	/^    pub fn get_pin(&self, pinid: PinId) -> Option<&Pin<'a>> {$/;"	P	implementation:GpioPorts
get_pin_number	gpio.rs	/^    pub fn get_pin_number(&self) -> u8 {$/;"	P	implementation:PinId
get_pinid	gpio.rs	/^    pub fn get_pinid(&self) -> PinId {$/;"	P	implementation:Pin
get_polarity	spi.rs	/^    fn get_polarity(&self) -> ClockPolarity {$/;"	P	implementation:Spi
get_port	gpio.rs	/^    pub fn get_port(&self, pinid: PinId) -> &Port {$/;"	P	implementation:GpioPorts
get_port_from_port_id	gpio.rs	/^    pub fn get_port_from_port_id(&self, portid: PortId) -> &Port {$/;"	P	implementation:GpioPorts
get_port_number	gpio.rs	/^    pub fn get_port_number(&self) -> u8 {$/;"	P	implementation:PinId
get_pullup_pulldown	gpio.rs	/^    fn get_pullup_pulldown(&self) -> PullUpPullDown {$/;"	P	implementation:Pin
get_rate	spi.rs	/^    fn get_rate(&self) -> u32 {$/;"	P	implementation:Spi
get_resolution_bits	adc.rs	/^    fn get_resolution_bits(&self) -> usize {$/;"	P	implementation:Adc
get_state	can.rs	/^    fn get_state(&self) -> Result<can::State, kernel::ErrorCode> {$/;"	P	implementation:Can
get_stream_idx	dma.rs	/^    pub fn get_stream_idx<'a>(&self) -> usize {$/;"	P	implementation:Dma1Peripheral
get_stream_idx	dma.rs	/^    pub fn get_stream_idx<'a>(&self) -> usize {$/;"	P	implementation:Dma2Peripheral
get_stream_irqn	dma.rs	/^    pub fn get_stream_irqn(&self) -> u32 {$/;"	P	implementation:Dma1Peripheral
get_stream_irqn	dma.rs	/^    pub fn get_stream_irqn(&self) -> u32 {$/;"	P	implementation:Dma2Peripheral
get_sys_clock_frequency	clk/clocks.rs	/^    pub fn get_sys_clock_frequency(&self) -> usize {$/;"	P	implementation:Clocks
get_sys_clock_source	clk/clocks.rs	/^    pub fn get_sys_clock_source(&self) -> SysClockSource {$/;"	P	implementation:Clocks
get_sys_clock_source	rcc.rs	/^    pub(crate) fn get_sys_clock_source(&self) -> SysClockSource {$/;"	P	implementation:Rcc
get_voltage_reference_mv	adc.rs	/^    fn get_voltage_reference_mv(&self) -> Option<usize> {$/;"	P	implementation:Adc
get_wake_up	can.rs	/^    fn get_wake_up(&self) -> Result<bool, kernel::ErrorCode> {$/;"	P	implementation:Can
gpio	lib.rs	/^pub mod gpio;$/;"	n
gpio_ports	chip.rs	/^    pub gpio_ports: crate::gpio::GpioPorts<'a>,$/;"	m	struct:Stm32f4xxDefaultPeripherals
gtpr	usart.rs	/^    gtpr: ReadWrite<u32, GTPR::Register>,$/;"	m	struct:UsartRegisters
handle_deferred_task	can.rs	/^    pub fn handle_deferred_task(&self) {$/;"	P	implementation:Can
handle_deferred_task	usart.rs	/^    pub fn handle_deferred_task(&self) {$/;"	P	implementation:Usart
handle_error	i2c.rs	/^    pub fn handle_error(&self) {$/;"	P	implementation:I2C
handle_error_status_interrupt	can.rs	/^    pub fn handle_error_status_interrupt(&self) {$/;"	P	implementation:Can
handle_event	i2c.rs	/^    pub fn handle_event(&self) {$/;"	P	implementation:I2C
handle_fifo0_interrupt	can.rs	/^    pub fn handle_fifo0_interrupt(&self) {$/;"	P	implementation:Can
handle_fifo1_interrupt	can.rs	/^    pub fn handle_fifo1_interrupt(&self) {$/;"	P	implementation:Can
handle_interrupt	adc.rs	/^    pub fn handle_interrupt(&self) {$/;"	P	implementation:Adc
handle_interrupt	dma.rs	/^    pub fn handle_interrupt(&self) {$/;"	P	implementation:Stream
handle_interrupt	exti.rs	/^    pub fn handle_interrupt(&self) {$/;"	P	implementation:Exti
handle_interrupt	fsmc.rs	/^    pub fn handle_interrupt(&self) {$/;"	P	implementation:Fsmc
handle_interrupt	gpio.rs	/^    pub fn handle_interrupt(&self) {$/;"	P	implementation:Pin
handle_interrupt	spi.rs	/^    pub fn handle_interrupt(&self) {$/;"	P	implementation:Spi
handle_interrupt	tim2.rs	/^    pub fn handle_interrupt(&self) {$/;"	P	implementation:Tim2
handle_interrupt	trng.rs	/^    pub fn handle_interrupt(&self) {$/;"	P	implementation:Trng
handle_interrupt	usart.rs	/^    pub fn handle_interrupt(&self) {$/;"	P	implementation:Usart
handle_transmit_interrupt	can.rs	/^    pub fn handle_transmit_interrupt(&self) {$/;"	P	implementation:Can
has_pending_interrupts	chip.rs	/^    fn has_pending_interrupts(&self) -> bool {$/;"	P	implementation:Stm32f4xx
hifcr	dma.rs	/^    hifcr: ReadWrite<u32, HIFCR::Register>,$/;"	m	struct:DmaRegisters
hisr	dma.rs	/^    hisr: ReadOnly<u32, HISR::Register>,$/;"	m	struct:DmaRegisters
hold_low	spi.rs	/^    fn hold_low(&self) {$/;"	P	implementation:Spi
hsi	clk/clocks.rs	/^    pub hsi: Hsi<'a>,$/;"	m	struct:Clocks
hsi	clk/mod.rs	/^pub mod hsi;$/;"	n
htr	adc.rs	/^    htr: ReadWrite<u32, HTR::Register>,$/;"	m	struct:AdcRegisters
i2c	lib.rs	/^pub mod i2c;$/;"	n
i2c1	chip.rs	/^    pub i2c1: crate::i2c::I2C<'a>,$/;"	m	struct:Stm32f4xxDefaultPeripherals
i2scfgr	spi.rs	/^    i2scfgr: ReadWrite<u32, I2SCFGR::Register>,$/;"	m	struct:SpiRegisters
i2spr	spi.rs	/^    i2spr: ReadWrite<u32, I2SPR::Register>,$/;"	m	struct:SpiRegisters
idr	gpio.rs	/^    idr: ReadOnly<u32, IDR::Register>,$/;"	m	struct:GpioRegisters
imr	exti.rs	/^    imr: ReadWrite<u32, IMR::Register>,$/;"	m	struct:ExtiRegisters
init	lib.rs	/^pub unsafe fn init() {$/;"	f
init	rcc.rs	/^    fn init(&self) {$/;"	P	implementation:Rcc
init	spi.rs	/^    fn init(&self) -> Result<(), ErrorCode> {$/;"	P	implementation:Spi
init_pll_clock	rcc.rs	/^    fn init_pll_clock(&self) {$/;"	P	implementation:Rcc
interrupt_enable	dma.rs	/^    fn interrupt_enable(&self) {$/;"	P	implementation:Stream
interrupt_service	chip.rs	/^    interrupt_service: &'a I,$/;"	m	struct:Stm32f4xx
into	deferred_calls.rs	/^    fn into(self) -> usize {$/;"	P	implementation:DeferredCallTask
irqn	tim2.rs	/^    irqn: u32,$/;"	m	struct:Tim2
is_armed	tim2.rs	/^    fn is_armed(&self) -> bool {$/;"	P	implementation:Tim2
is_busy	spi.rs	/^    fn is_busy(&self) -> bool {$/;"	P	implementation:Spi
is_enabled	adc.rs	/^    fn is_enabled(&self) -> bool {$/;"	P	implementation:AdcClock
is_enabled	can.rs	/^    fn is_enabled(&self) -> bool {$/;"	P	implementation:CanClock
is_enabled	clk/hsi.rs	/^    pub fn is_enabled(&self) -> bool {$/;"	P	implementation:Hsi
is_enabled	clk/pll.rs	/^    pub fn is_enabled(&self) -> bool {$/;"	P	implementation:Pll
is_enabled	dma.rs	/^    fn is_enabled(&self) -> bool {$/;"	P	implementation:DmaClock
is_enabled	exti.rs	/^    fn is_enabled(&self) -> bool {$/;"	P	implementation:ExtiClock
is_enabled	fsmc.rs	/^    fn is_enabled(&self) -> bool {$/;"	P	implementation:FsmcClock
is_enabled	gpio.rs	/^    fn is_enabled(&self) -> bool {$/;"	P	implementation:PortClock
is_enabled	i2c.rs	/^    fn is_enabled(&self) -> bool {$/;"	P	implementation:I2CClock
is_enabled	rcc.rs	/^    fn is_enabled(&self) -> bool {$/;"	P	implementation:PeripheralClock
is_enabled	spi.rs	/^    fn is_enabled(&self) -> bool {$/;"	P	implementation:SpiClock
is_enabled	syscfg.rs	/^    fn is_enabled(&self) -> bool {$/;"	P	implementation:SyscfgClock
is_enabled	tim2.rs	/^    fn is_enabled(&self) -> bool {$/;"	P	implementation:Tim2Clock
is_enabled	trng.rs	/^    fn is_enabled(&self) -> bool {$/;"	P	implementation:RngClock
is_enabled	usart.rs	/^    fn is_enabled(&self) -> bool {$/;"	P	implementation:UsartClock
is_enabled_adc1_clock	rcc.rs	/^    fn is_enabled_adc1_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_can1_clock	rcc.rs	/^    fn is_enabled_can1_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_clock	adc.rs	/^    pub fn is_enabled_clock(&self) -> bool {$/;"	P	implementation:Adc
is_enabled_clock	can.rs	/^    pub fn is_enabled_clock(&self) -> bool {$/;"	P	implementation:Can
is_enabled_clock	dma.rs	/^    pub fn is_enabled_clock(&self) -> bool {$/;"	P	implementation:Dma1
is_enabled_clock	dma.rs	/^    pub fn is_enabled_clock(&self) -> bool {$/;"	P	implementation:Dma2
is_enabled_clock	exti.rs	/^    pub fn is_enabled_clock(&self) -> bool {$/;"	P	implementation:Exti
is_enabled_clock	gpio.rs	/^    pub fn is_enabled_clock(&self) -> bool {$/;"	P	implementation:Port
is_enabled_clock	i2c.rs	/^    pub fn is_enabled_clock(&self) -> bool {$/;"	P	implementation:I2C
is_enabled_clock	spi.rs	/^    pub fn is_enabled_clock(&self) -> bool {$/;"	P	implementation:Spi
is_enabled_clock	syscfg.rs	/^    pub fn is_enabled_clock(&self) -> bool {$/;"	P	implementation:Syscfg
is_enabled_clock	tim2.rs	/^    pub fn is_enabled_clock(&self) -> bool {$/;"	P	implementation:Tim2
is_enabled_clock	trng.rs	/^    pub fn is_enabled_clock(&self) -> bool {$/;"	P	implementation:Trng
is_enabled_clock	usart.rs	/^    pub fn is_enabled_clock(&self) -> bool {$/;"	P	implementation:Usart
is_enabled_dma1_clock	rcc.rs	/^    fn is_enabled_dma1_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_dma2_clock	rcc.rs	/^    fn is_enabled_dma2_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_fmc_clock	rcc.rs	/^    fn is_enabled_fmc_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_gpioa_clock	rcc.rs	/^    fn is_enabled_gpioa_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_gpiob_clock	rcc.rs	/^    fn is_enabled_gpiob_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_gpioc_clock	rcc.rs	/^    fn is_enabled_gpioc_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_gpiod_clock	rcc.rs	/^    fn is_enabled_gpiod_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_gpioe_clock	rcc.rs	/^    fn is_enabled_gpioe_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_gpiof_clock	rcc.rs	/^    fn is_enabled_gpiof_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_gpiog_clock	rcc.rs	/^    fn is_enabled_gpiog_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_gpioh_clock	rcc.rs	/^    fn is_enabled_gpioh_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_hsi_clock	rcc.rs	/^    pub(crate) fn is_enabled_hsi_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_i2c1_clock	rcc.rs	/^    fn is_enabled_i2c1_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_otgfs_clock	rcc.rs	/^    fn is_enabled_otgfs_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_pll_clock	rcc.rs	/^    pub(crate) fn is_enabled_pll_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_rng_clock	rcc.rs	/^    fn is_enabled_rng_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_spi3_clock	rcc.rs	/^    fn is_enabled_spi3_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_syscfg_clock	rcc.rs	/^    fn is_enabled_syscfg_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_tim2_clock	rcc.rs	/^    fn is_enabled_tim2_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_usart1_clock	rcc.rs	/^    fn is_enabled_usart1_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_usart2_clock	rcc.rs	/^    fn is_enabled_usart2_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_enabled_usart3_clock	rcc.rs	/^    fn is_enabled_usart3_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_hsi_clock_system_clock	rcc.rs	/^    pub(crate) fn is_hsi_clock_system_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_input	gpio.rs	/^    fn is_input(&self) -> bool {$/;"	P	implementation:Pin
is_locked_pll_clock	rcc.rs	/^    pub(crate) fn is_locked_pll_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_output	gpio.rs	/^    fn is_output(&self) -> bool {$/;"	P	implementation:Pin
is_output_high	gpio.rs	/^    fn is_output_high(&self) -> bool {$/;"	P	implementation:Pin
is_pending	exti.rs	/^    pub fn is_pending(&self, lineid: LineId) -> bool {$/;"	P	implementation:Exti
is_pending	gpio.rs	/^    fn is_pending(&self) -> bool {$/;"	P	implementation:Pin
is_pll48_calibrated	clk/pll.rs	/^    pub fn is_pll48_calibrated(&self) -> bool {$/;"	P	implementation:Pll
is_ready_hsi_clock	rcc.rs	/^    pub(crate) fn is_ready_hsi_clock(&self) -> bool {$/;"	P	implementation:Rcc
is_running	tim2.rs	/^    fn is_running(&self) -> bool {$/;"	P	implementation:Tim2
jdr1	adc.rs	/^    jdr1: ReadOnly<u32, JDR::Register>,$/;"	m	struct:AdcRegisters
jdr2	adc.rs	/^    jdr2: ReadOnly<u32, JDR::Register>,$/;"	m	struct:AdcRegisters
jdr3	adc.rs	/^    jdr3: ReadOnly<u32, JDR::Register>,$/;"	m	struct:AdcRegisters
jdr4	adc.rs	/^    jdr4: ReadOnly<u32, JDR::Register>,$/;"	m	struct:AdcRegisters
jofr1	adc.rs	/^    jofr1: ReadWrite<u32, JOFR::Register>,$/;"	m	struct:AdcRegisters
jofr2	adc.rs	/^    jofr2: ReadWrite<u32, JOFR::Register>,$/;"	m	struct:AdcRegisters
jofr3	adc.rs	/^    jofr3: ReadWrite<u32, JOFR::Register>,$/;"	m	struct:AdcRegisters
jofr4	adc.rs	/^    jofr4: ReadWrite<u32, JOFR::Register>,$/;"	m	struct:AdcRegisters
jsqr	adc.rs	/^    jsqr: ReadWrite<u32, JSQR::Register>,$/;"	m	struct:AdcRegisters
lckr	gpio.rs	/^    lckr: ReadWrite<u32, LCKR::Register>,$/;"	m	struct:GpioRegisters
len	fsmc.rs	/^    len: Cell<usize>,$/;"	m	struct:Fsmc
lifcr	dma.rs	/^    lifcr: ReadWrite<u32, LIFCR::Register>,$/;"	m	struct:DmaRegisters
line_gpiopin_map	exti.rs	/^    line_gpiopin_map: [OptionalCell<&'static gpio::Pin<'static>>; 16],$/;"	m	struct:Exti
lisr	dma.rs	/^    lisr: ReadOnly<u32, LISR::Register>,$/;"	m	struct:DmaRegisters
ltr	adc.rs	/^    ltr: ReadWrite<u32, LTR::Register>,$/;"	m	struct:AdcRegisters
make_input	gpio.rs	/^    fn make_input(&self) -> hil::gpio::Configuration {$/;"	P	implementation:Pin
make_output	gpio.rs	/^    fn make_output(&self) -> hil::gpio::Configuration {$/;"	P	implementation:Pin
mask_interrupt	exti.rs	/^    pub fn mask_interrupt(&self, lineid: LineId) {$/;"	P	implementation:Exti
master_client	i2c.rs	/^    master_client: OptionalCell<&'a dyn hil::i2c::I2CHwMasterClient>,$/;"	m	struct:I2C
master_client	spi.rs	/^    master_client: OptionalCell<&'a dyn hil::spi::SpiMasterClient>,$/;"	m	struct:Spi
memrm	syscfg.rs	/^    memrm: ReadWrite<u32, MEMRM::Register>,$/;"	m	struct:SyscfgRegisters
minimum_dt	tim2.rs	/^    fn minimum_dt(&self) -> Self::Ticks {$/;"	P	implementation:Tim2
moder	gpio.rs	/^    moder: ReadWrite<u32, MODER::Register>,$/;"	m	struct:GpioRegisters
mpu	chip.rs	/^    fn mpu(&self) -> &cortexm4::mpu::MPU {$/;"	P	implementation:Stm32f4xx
mpu	chip.rs	/^    mpu: cortexm4::mpu::MPU,$/;"	m	struct:Stm32f4xx
new	adc.rs	/^    pub const fn new(rcc: &'a rcc::Rcc) -> Adc {$/;"	P	implementation:Adc
new	can.rs	/^    pub fn new(rcc: &'a rcc::Rcc, registers: StaticRef<Registers>) -> Can<'a> {$/;"	P	implementation:Can
new	chip.rs	/^    pub fn new($/;"	P	implementation:Stm32f4xxDefaultPeripherals
new	chip.rs	/^    pub unsafe fn new(interrupt_service: &'a I) -> Self {$/;"	P	implementation:Stm32f4xx
new	clk/clocks.rs	/^    pub(crate) fn new(rcc: &'a Rcc) -> Self {$/;"	P	implementation:Clocks
new	clk/hsi.rs	/^    pub fn new(rcc: &'a Rcc) -> Self {$/;"	P	implementation:Hsi
new	clk/pll.rs	/^    pub(crate) fn new(rcc: &'a Rcc) -> Self {$/;"	P	implementation:Pll
new	dbg.rs	/^    pub const fn new() -> Dbg {$/;"	P	implementation:Dbg
new	dma.rs	/^    fn new(streamid: StreamId, dma: &'a DMA) -> Self {$/;"	P	implementation:Stream
new	dma.rs	/^    pub const fn new(rcc: &'a rcc::Rcc) -> Dma1 {$/;"	P	implementation:Dma1
new	dma.rs	/^    pub const fn new(rcc: &'a rcc::Rcc) -> Dma2 {$/;"	P	implementation:Dma2
new	exti.rs	/^    pub const fn new(syscfg: &'a syscfg::Syscfg<'a>) -> Self {$/;"	P	implementation:Exti
new	flash.rs	/^    pub(crate) fn new() -> Self {$/;"	P	implementation:Flash
new	fsmc.rs	/^    pub fn new(bank_addr: [Option<StaticRef<FsmcBank>>; 4], rcc: &'a rcc::Rcc) -> Self {$/;"	P	implementation:Fsmc
new	gpio.rs	/^    pub const fn new(pinid: PinId, exti: &'a exti::Exti<'a>) -> Self {$/;"	P	implementation:Pin
new	gpio.rs	/^    pub fn new(rcc: &'a rcc::Rcc, exti: &'a exti::Exti<'a>) -> Self {$/;"	P	implementation:GpioPorts
new	i2c.rs	/^    pub fn new(rcc: &'a rcc::Rcc) -> Self {$/;"	P	implementation:I2C
new	rcc.rs	/^    pub const fn new(clock: PeripheralClockType, rcc: &'a Rcc) -> Self {$/;"	P	implementation:PeripheralClock
new	rcc.rs	/^    pub fn new() -> Self {$/;"	P	implementation:Rcc
new	spi.rs	/^    pub const fn new($/;"	P	implementation:Spi
new	syscfg.rs	/^    pub const fn new(rcc: &'a rcc::Rcc) -> Self {$/;"	P	implementation:Syscfg
new	tim2.rs	/^    pub const fn new(rcc: &'a rcc::Rcc) -> Self {$/;"	P	implementation:Tim2
new	trng.rs	/^    pub const fn new(registers: StaticRef<RngRegisters>, rcc: &'a rcc::Rcc) -> Trng<'a> {$/;"	P	implementation:Trng
new	usart.rs	/^    fn new($/;"	P	implementation:Usart
new_dma1_stream	dma.rs	/^pub fn new_dma1_stream<'a>(dma: &'a Dma1) -> [Stream<'a, Dma1<'a>>; 8] {$/;"	f
new_dma2_stream	dma.rs	/^pub fn new_dma2_stream<'a>(dma: &'a Dma2) -> [Stream<'a, Dma2<'a>>; 8] {$/;"	f
new_usart1	usart.rs	/^    pub fn new_usart1(rcc: &'a rcc::Rcc) -> Self {$/;"	P	implementation:Usart
new_usart2	usart.rs	/^    pub fn new_usart2(rcc: &'a rcc::Rcc) -> Self {$/;"	P	implementation:Usart
new_usart3	usart.rs	/^    pub fn new_usart3(rcc: &'a rcc::Rcc) -> Self {$/;"	P	implementation:Usart
next	trng.rs	/^    fn next(&mut self) -> Option<u32> {$/;"	P	implementation:TrngIter
now	tim2.rs	/^    fn now(&self) -> Ticks32 {$/;"	P	implementation:Tim2
nvic	lib.rs	/^pub mod nvic;$/;"	n
oar1	i2c.rs	/^    oar1: ReadWrite<u32, OAR1::Register>,$/;"	m	struct:I2CRegisters
oar2	i2c.rs	/^    oar2: ReadWrite<u32, OAR2::Register>,$/;"	m	struct:I2CRegisters
odr	gpio.rs	/^    odr: ReadWrite<u32, ODR::Register>,$/;"	m	struct:GpioRegisters
operating_mode	can.rs	/^    operating_mode: OptionalCell<can::OperationMode>,$/;"	m	struct:Can
or_	tim2.rs	/^    or_: ReadWrite<u32>,$/;"	m	struct:Tim2Registers
ospeedr	gpio.rs	/^    ospeedr: ReadWrite<u32, OSPEEDR::Register>,$/;"	m	struct:GpioRegisters
otyper	gpio.rs	/^    otyper: ReadWrite<u32, OTYPER::Register>,$/;"	m	struct:GpioRegisters
partial_rx_buffer	usart.rs	/^    partial_rx_buffer: TakeCell<'static, [u8]>,$/;"	m	struct:Usart
partial_rx_len	usart.rs	/^    partial_rx_len: Cell<usize>,$/;"	m	struct:Usart
partial_tx_buffer	usart.rs	/^    partial_tx_buffer: TakeCell<'static, [u8]>,$/;"	m	struct:Usart
partial_tx_len	usart.rs	/^    partial_tx_len: Cell<usize>,$/;"	m	struct:Usart
peripheral	dma.rs	/^    peripheral: OptionalCell<DMA::Peripheral>,$/;"	m	struct:Stream
pinid	gpio.rs	/^    pinid: PinId,$/;"	m	struct:Pin
pins	gpio.rs	/^    pub pins: [[Option<Pin<'a>>; 16]; 8],$/;"	m	struct:GpioPorts
pll	clk/clocks.rs	/^    pub pll: Pll<'a>,$/;"	m	struct:Clocks
pll	clk/mod.rs	/^pub mod pll;$/;"	n
pll48_calibrated	clk/pll.rs	/^    pll48_calibrated: OptionalCell<bool>,$/;"	m	struct:Pll
pll48_frequency	clk/pll.rs	/^    pll48_frequency: OptionalCell<usize>,$/;"	m	struct:Pll
pllcfgr	rcc.rs	/^    pllcfgr: ReadWrite<u32, PLLCFGR::Register>,$/;"	m	struct:RccRegisters
plli2scfgr	rcc.rs	/^    plli2scfgr: ReadWrite<u32, PLLI2SCFGR::Register>,$/;"	m	struct:RccRegisters
pllsaicfgr	rcc.rs	/^    pllsaicfgr: ReadWrite<u32, PLLSAICFGR::Register>,$/;"	m	struct:RccRegisters
pmc	syscfg.rs	/^    pmc: ReadWrite<u32, PMC::Register>,$/;"	m	struct:SyscfgRegisters
ports	gpio.rs	/^    ports: [Port<'a>; 8],$/;"	m	struct:GpioPorts
ports_ref	gpio.rs	/^    ports_ref: OptionalCell<&'a GpioPorts<'a>>,$/;"	m	struct:Pin
pr	exti.rs	/^    pr: ReadWrite<u32, PR::Register>,$/;"	m	struct:ExtiRegisters
print_state	chip.rs	/^    unsafe fn print_state(&self, write: &mut dyn Write) {$/;"	P	implementation:Stm32f4xx
process_received_message	can.rs	/^    pub fn process_received_message($/;"	P	implementation:Can
provide_buffer	adc.rs	/^    fn provide_buffer($/;"	P	implementation:Adc
psc	tim2.rs	/^    psc: ReadWrite<u32>,$/;"	m	struct:Tim2Registers
pupdr	gpio.rs	/^    pupdr: ReadWrite<u32, PUPDR::Register>,$/;"	m	struct:GpioRegisters
ram	fsmc.rs	/^    ram: ReadWrite<u16>,$/;"	m	struct:FsmcBank
rcc	clk/clocks.rs	/^    rcc: &'a Rcc,$/;"	m	struct:Clocks
rcc	clk/hsi.rs	/^    rcc: &'a Rcc,$/;"	m	struct:Hsi
rcc	clk/pll.rs	/^    rcc: &'a Rcc,$/;"	m	struct:Pll
rcc	lib.rs	/^pub mod rcc;$/;"	n
rcc	rcc.rs	/^    rcc: &'a Rcc,$/;"	m	struct:PeripheralClock
read	fsmc.rs	/^    fn read($/;"	P	implementation:Fsmc
read	gpio.rs	/^    fn read(&self) -> bool {$/;"	P	implementation:Pin
read	i2c.rs	/^    fn read($/;"	P	implementation:I2C
read_byte	spi.rs	/^    fn read_byte(&self) -> Result<u8, ErrorCode> {$/;"	P	implementation:Spi
read_input	gpio.rs	/^    fn read_input(&self) -> bool {$/;"	P	implementation:Pin
read_reg	fsmc.rs	/^    pub fn read_reg(&self, bank: FsmcBanks) -> Option<u16> {$/;"	P	implementation:Fsmc
read_write_byte	spi.rs	/^    fn read_write_byte(&self, val: u8) -> Result<u8, ErrorCode> {$/;"	P	implementation:Spi
read_write_bytes	spi.rs	/^    fn read_write_bytes($/;"	P	implementation:Spi
receive_abort	usart.rs	/^    fn receive_abort(&self) -> Result<(), ErrorCode> {$/;"	P	implementation:Usart
receive_buffer	usart.rs	/^    fn receive_buffer($/;"	P	implementation:Usart
receive_client	can.rs	/^    receive_client:$/;"	m	struct:Can
receive_fifo_count	can.rs	/^    fn receive_fifo_count(&self) -> usize {$/;"	P	implementation:Can
receive_word	usart.rs	/^    fn receive_word(&self) -> Result<(), ErrorCode> {$/;"	P	implementation:Usart
reg	fsmc.rs	/^    reg: ReadWrite<u16>,$/;"	m	struct:FsmcBank
registers	adc.rs	/^    registers: StaticRef<AdcRegisters>,$/;"	m	struct:Adc
registers	can.rs	/^    registers: StaticRef<Registers>,$/;"	m	struct:Can
registers	dbg.rs	/^    registers: StaticRef<DbgRegisters>,$/;"	m	struct:Dbg
registers	dma.rs	/^    fn registers(&self) -> &DmaRegisters {$/;"	P	implementation:Dma1
registers	dma.rs	/^    fn registers(&self) -> &DmaRegisters {$/;"	P	implementation:Dma2
registers	dma.rs	/^    fn registers(&self) -> &DmaRegisters;$/;"	P	interface:StreamServer
registers	dma.rs	/^    registers: StaticRef<DmaRegisters>,$/;"	m	struct:Dma1
registers	dma.rs	/^    registers: StaticRef<DmaRegisters>,$/;"	m	struct:Dma2
registers	exti.rs	/^    registers: StaticRef<ExtiRegisters>,$/;"	m	struct:Exti
registers	flash.rs	/^    registers: StaticRef<FlashRegisters>,$/;"	m	struct:Flash
registers	fsmc.rs	/^    registers: StaticRef<FsmcBankRegisters>,$/;"	m	struct:Fsmc
registers	gpio.rs	/^    registers: StaticRef<GpioRegisters>,$/;"	m	struct:Port
registers	i2c.rs	/^    registers: StaticRef<I2CRegisters>,$/;"	m	struct:I2C
registers	rcc.rs	/^    registers: StaticRef<RccRegisters>,$/;"	m	struct:Rcc
registers	spi.rs	/^    registers: StaticRef<SpiRegisters>,$/;"	m	struct:Spi
registers	syscfg.rs	/^    registers: StaticRef<SyscfgRegisters>,$/;"	m	struct:Syscfg
registers	tim2.rs	/^    registers: StaticRef<Tim2Registers>,$/;"	m	struct:Tim2
registers	trng.rs	/^    registers: StaticRef<RngRegisters>,$/;"	m	struct:Trng
registers	usart.rs	/^    registers: StaticRef<UsartRegisters>,$/;"	m	struct:Usart
release_low	spi.rs	/^    fn release_low(&self) {$/;"	P	implementation:Spi
reset	i2c.rs	/^    fn reset(&self) {$/;"	P	implementation:I2C
reset	tim2.rs	/^    fn reset(&self) -> Result<(), ErrorCode> {$/;"	P	implementation:Tim2
retrieve_buffers	adc.rs	/^    fn retrieve_buffers($/;"	P	implementation:Adc
return_buffer	dma.rs	/^    pub fn return_buffer(&self) -> Option<&'static mut [u8]> {$/;"	P	implementation:Stream
rtsr	exti.rs	/^    rtsr: ReadWrite<u32, RTSR::Register>,$/;"	m	struct:ExtiRegisters
run	clk/hsi.rs	/^    pub fn run(hsi: &Hsi) {$/;"	f	module:tests
run	clk/pll.rs	/^    pub fn run<'a>(pll: &'a Pll<'a>) {$/;"	f	module:tests
run_all	clk/clocks.rs	/^    pub fn run_all(clocks: &Clocks) {$/;"	f	module:tests
run_all	flash.rs	/^    pub fn run_all(flash: &Flash) {$/;"	f	module:tests
rx_buffer	can.rs	/^    rx_buffer: TakeCell<'static, [u8; can::STANDARD_CAN_PACKET_SIZE]>,$/;"	m	struct:Can
rx_client	usart.rs	/^    rx_client: OptionalCell<&'a dyn hil::uart::ReceiveClient>,$/;"	m	struct:Usart
rx_dma	spi.rs	/^    rx_dma: OptionalCell<&'a dma::Stream<'a, Dma1<'a>>>,$/;"	m	struct:Spi
rx_dma	usart.rs	/^    rx_dma: OptionalCell<&'a dma::Stream<'a, DMA>>,$/;"	m	struct:Usart
rx_dma_pid	spi.rs	/^    rx_dma_pid: Dma1Peripheral,$/;"	m	struct:Spi
rx_dma_pid	usart.rs	/^    rx_dma_pid: DMA::Peripheral,$/;"	m	struct:Usart
rx_len	i2c.rs	/^    rx_len: Cell<usize>,$/;"	m	struct:I2C
rx_len	usart.rs	/^    rx_len: Cell<usize>,$/;"	m	struct:Usart
rx_position	i2c.rs	/^    rx_position: Cell<usize>,$/;"	m	struct:I2C
rxcrcr	spi.rs	/^    rxcrcr: ReadOnly<u32>,$/;"	m	struct:SpiRegisters
s0cr	dma.rs	/^    s0cr: ReadWrite<u32, S0CR::Register>,$/;"	m	struct:DmaRegisters
s0fcr	dma.rs	/^    s0fcr: ReadWrite<u32, S0FCR::Register>,$/;"	m	struct:DmaRegisters
s0m0ar	dma.rs	/^    s0m0ar: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s0m1ar	dma.rs	/^    s0m1ar: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s0ndtr	dma.rs	/^    s0ndtr: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s0par	dma.rs	/^    s0par: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s1cr	dma.rs	/^    s1cr: ReadWrite<u32, S1CR::Register>,$/;"	m	struct:DmaRegisters
s1fcr	dma.rs	/^    s1fcr: ReadWrite<u32, S1FCR::Register>,$/;"	m	struct:DmaRegisters
s1m0ar	dma.rs	/^    s1m0ar: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s1m1ar	dma.rs	/^    s1m1ar: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s1ndtr	dma.rs	/^    s1ndtr: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s1par	dma.rs	/^    s1par: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s2cr	dma.rs	/^    s2cr: ReadWrite<u32, S2CR::Register>,$/;"	m	struct:DmaRegisters
s2fcr	dma.rs	/^    s2fcr: ReadWrite<u32, S2FCR::Register>,$/;"	m	struct:DmaRegisters
s2m0ar	dma.rs	/^    s2m0ar: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s2m1ar	dma.rs	/^    s2m1ar: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s2ndtr	dma.rs	/^    s2ndtr: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s2par	dma.rs	/^    s2par: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s3cr	dma.rs	/^    s3cr: ReadWrite<u32, S3CR::Register>,$/;"	m	struct:DmaRegisters
s3fcr	dma.rs	/^    s3fcr: ReadWrite<u32, S3FCR::Register>,$/;"	m	struct:DmaRegisters
s3m0ar	dma.rs	/^    s3m0ar: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s3m1ar	dma.rs	/^    s3m1ar: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s3ndtr	dma.rs	/^    s3ndtr: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s3par	dma.rs	/^    s3par: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s4cr	dma.rs	/^    s4cr: ReadWrite<u32, S4CR::Register>,$/;"	m	struct:DmaRegisters
s4fcr	dma.rs	/^    s4fcr: ReadWrite<u32, S4FCR::Register>,$/;"	m	struct:DmaRegisters
s4m0ar	dma.rs	/^    s4m0ar: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s4m1ar	dma.rs	/^    s4m1ar: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s4ndtr	dma.rs	/^    s4ndtr: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s4par	dma.rs	/^    s4par: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s5cr	dma.rs	/^    s5cr: ReadWrite<u32, S5CR::Register>,$/;"	m	struct:DmaRegisters
s5fcr	dma.rs	/^    s5fcr: ReadWrite<u32, S5FCR::Register>,$/;"	m	struct:DmaRegisters
s5m0ar	dma.rs	/^    s5m0ar: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s5m1ar	dma.rs	/^    s5m1ar: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s5ndtr	dma.rs	/^    s5ndtr: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s5par	dma.rs	/^    s5par: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s6cr	dma.rs	/^    s6cr: ReadWrite<u32, S6CR::Register>,$/;"	m	struct:DmaRegisters
s6fcr	dma.rs	/^    s6fcr: ReadWrite<u32, S6FCR::Register>,$/;"	m	struct:DmaRegisters
s6m0ar	dma.rs	/^    s6m0ar: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s6m1ar	dma.rs	/^    s6m1ar: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s6ndtr	dma.rs	/^    s6ndtr: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s6par	dma.rs	/^    s6par: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s7cr	dma.rs	/^    s7cr: ReadWrite<u32, S7CR::Register>,$/;"	m	struct:DmaRegisters
s7fcr	dma.rs	/^    s7fcr: ReadWrite<u32, S7FCR::Register>,$/;"	m	struct:DmaRegisters
s7m0ar	dma.rs	/^    s7m0ar: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s7m1ar	dma.rs	/^    s7m1ar: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s7ndtr	dma.rs	/^    s7ndtr: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
s7par	dma.rs	/^    s7par: ReadWrite<u32>,$/;"	m	struct:DmaRegisters
sample	adc.rs	/^    fn sample(&self, channel: &Self::Channel) -> Result<(), ErrorCode> {$/;"	P	implementation:Adc
sample_continuous	adc.rs	/^    fn sample_continuous($/;"	P	implementation:Adc
sample_highspeed	adc.rs	/^    fn sample_highspeed($/;"	P	implementation:Adc
select_falling_trigger	exti.rs	/^    pub fn select_falling_trigger(&self, lineid: LineId) {$/;"	P	implementation:Exti
select_rising_trigger	exti.rs	/^    pub fn select_rising_trigger(&self, lineid: LineId) {$/;"	P	implementation:Exti
send	can.rs	/^    fn send($/;"	P	implementation:Can
send_8byte_message	can.rs	/^    pub fn send_8byte_message($/;"	P	implementation:Can
send_byte	usart.rs	/^    pub fn send_byte(&self, byte: u8) {$/;"	P	implementation:Usart
service_deferred_call	chip.rs	/^    unsafe fn service_deferred_call(&self, task: DeferredCallTask) -> bool {$/;"	P	implementation:Stm32f4xxDefaultPeripherals
service_interrupt	chip.rs	/^    unsafe fn service_interrupt(&self, interrupt: u32) -> bool {$/;"	P	implementation:Stm32f4xxDefaultPeripherals
service_pending_interrupts	chip.rs	/^    fn service_pending_interrupts(&self) {$/;"	P	implementation:Stm32f4xx
set	gpio.rs	/^    fn set(&self) {$/;"	P	implementation:Pin
set_active_slave	spi.rs	/^    fn set_active_slave(&self, slave_pin: &'a crate::gpio::Pin<'a>) {$/;"	P	implementation:Spi
set_addr	fsmc.rs	/^    fn set_addr(&self, addr_width: BusWidth, addr: usize) -> Result<(), ErrorCode> {$/;"	P	implementation:Fsmc
set_ahb_prescaler	clk/clocks.rs	/^    pub fn set_ahb_prescaler(&self, prescaler: AHBPrescaler) -> Result<(), ErrorCode> {$/;"	P	implementation:Clocks
set_ahb_prescaler	rcc.rs	/^    pub(crate) fn set_ahb_prescaler(&self, ahb_prescaler: AHBPrescaler) {$/;"	P	implementation:Rcc
set_alarm	tim2.rs	/^    fn set_alarm(&self, reference: Self::Ticks, dt: Self::Ticks) {$/;"	P	implementation:Tim2
set_alarm_client	tim2.rs	/^    fn set_alarm_client(&self, client: &'a dyn AlarmClient) {$/;"	P	implementation:Tim2
set_alternate_function	gpio.rs	/^    pub fn set_alternate_function(&self, af: AlternateFunction) {$/;"	P	implementation:Pin
set_apb1_prescaler	clk/clocks.rs	/^    pub fn set_apb1_prescaler(&self, prescaler: APBPrescaler) -> Result<(), ErrorCode> {$/;"	P	implementation:Clocks
set_apb1_prescaler	rcc.rs	/^    pub(crate) fn set_apb1_prescaler(&self, apb1_prescaler: APBPrescaler) {$/;"	P	implementation:Rcc
set_apb2_prescaler	clk/clocks.rs	/^    pub fn set_apb2_prescaler(&self, prescaler: APBPrescaler) -> Result<(), ErrorCode> {$/;"	P	implementation:Clocks
set_apb2_prescaler	rcc.rs	/^    pub(crate) fn set_apb2_prescaler(&self, apb2_prescaler: APBPrescaler) {$/;"	P	implementation:Rcc
set_automatic_retransmission	can.rs	/^    fn set_automatic_retransmission(&self, automatic: bool) -> Result<(), kernel::ErrorCode> {$/;"	P	implementation:Can
set_bit_timing	can.rs	/^    fn set_bit_timing(&self, bit_timing: can::BitTiming) -> Result<(), kernel::ErrorCode> {$/;"	P	implementation:Can
set_bitrate	can.rs	/^    fn set_bitrate(&self, bitrate: u32) -> Result<(), kernel::ErrorCode> {$/;"	P	implementation:Can
set_channel	dma.rs	/^    fn set_channel(&self) {$/;"	P	implementation:Stream
set_client	adc.rs	/^    fn set_client(&self, client: &'static dyn hil::adc::Client) {$/;"	P	implementation:Adc
set_client	can.rs	/^    fn set_client(&self, client: Option<&'static dyn can::ControllerClient>) {$/;"	P	implementation:Can
set_client	dma.rs	/^    pub fn set_client(&self, client: &'a dyn StreamClient<'a, DMA>) {$/;"	P	implementation:Stream
set_client	fsmc.rs	/^    fn set_client(&self, client: &'static dyn Client) {$/;"	P	implementation:Fsmc
set_client	gpio.rs	/^    fn set_client(&self, client: &'a dyn hil::gpio::Client) {$/;"	P	implementation:Pin
set_client	gpio.rs	/^    pub fn set_client(&self, client: &'a dyn hil::gpio::Client) {$/;"	P	implementation:Pin
set_client	spi.rs	/^    fn set_client(&self, client: &'static dyn SpiMasterClient) {$/;"	P	implementation:Spi
set_client	trng.rs	/^    fn set_client(&'a self, client: &'a dyn hil::entropy::Client32) {$/;"	P	implementation:Trng
set_cr	spi.rs	/^    fn set_cr<F>(&self, f: F)$/;"	P	implementation:Spi
set_data_items	dma.rs	/^    fn set_data_items(&self, data_items: u32) {$/;"	P	implementation:Stream
set_data_width_for_peripheral	dma.rs	/^    fn set_data_width_for_peripheral(&self) {$/;"	P	implementation:Stream
set_default_configuration	clk/clocks.rs	/^    fn set_default_configuration(clocks: &Clocks) {$/;"	f	module:tests
set_direction	dma.rs	/^    fn set_direction(&self) {$/;"	P	implementation:Stream
set_dma	spi.rs	/^    pub fn set_dma(&self, tx_dma: TxDMA<'a>, rx_dma: RxDMA<'a>) {$/;"	P	implementation:Spi
set_dma	usart.rs	/^    pub fn set_dma(&self, tx_dma: TxDMA<'a, DMA>, rx_dma: RxDMA<'a, DMA>) {$/;"	P	implementation:Usart
set_exti_lineid	gpio.rs	/^    pub fn set_exti_lineid(&self, lineid: exti::LineId) {$/;"	P	implementation:Pin
set_flash	clk/clocks.rs	/^    pub(crate) fn set_flash(&self, flash: &'a Flash) {$/;"	P	implementation:Clocks
set_floating_state	gpio.rs	/^    fn set_floating_state(&self, mode: hil::gpio::FloatingState) {$/;"	P	implementation:Pin
set_frequency	clk/pll.rs	/^    pub fn set_frequency(&self, desired_frequency_mhz: usize) -> Result<(), ErrorCode> {$/;"	P	implementation:Pll
set_highspeed_client	adc.rs	/^    fn set_highspeed_client(&self, _client: &'static dyn hil::adc::HighSpeedClient) {}$/;"	P	implementation:Adc
set_latency	flash.rs	/^    pub(crate) fn set_latency(&self, sys_clock_frequency: usize) -> Result<(), ErrorCode> {$/;"	P	implementation:Flash
set_master_client	i2c.rs	/^    fn set_master_client(&self, master_client: &'static dyn I2CHwMasterClient) {$/;"	P	implementation:I2C
set_memory_address	dma.rs	/^    fn set_memory_address(&self, buf_addr: u32) {$/;"	P	implementation:Stream
set_memory_address_increment	dma.rs	/^    fn set_memory_address_increment(&self) {$/;"	P	implementation:Stream
set_mode	gpio.rs	/^    pub fn set_mode(&self, mode: Mode) {$/;"	P	implementation:Pin
set_mode_output_opendrain	gpio.rs	/^    pub fn set_mode_output_opendrain(&self) {$/;"	P	implementation:Pin
set_mode_output_pushpull	gpio.rs	/^    fn set_mode_output_pushpull(&self) {$/;"	P	implementation:Pin
set_operation_mode	can.rs	/^    fn set_operation_mode(&self, mode: can::OperationMode) -> Result<(), kernel::ErrorCode> {$/;"	P	implementation:Can
set_output_high	gpio.rs	/^    fn set_output_high(&self) {$/;"	P	implementation:Pin
set_output_low	gpio.rs	/^    fn set_output_low(&self) {$/;"	P	implementation:Pin
set_overflow_client	tim2.rs	/^    fn set_overflow_client(&self, _client: &'a dyn OverflowClient) {}$/;"	P	implementation:Tim2
set_peripheral_address	dma.rs	/^    fn set_peripheral_address(&self) {$/;"	P	implementation:Stream
set_peripheral_address_increment	dma.rs	/^    fn set_peripheral_address_increment(&self) {$/;"	P	implementation:Stream
set_phase	spi.rs	/^    fn set_phase(&self, phase: ClockPhase) -> Result<(), ErrorCode> {$/;"	P	implementation:Spi
set_phase	spi.rs	/^    fn set_phase(&self, phase: ClockPhase) {$/;"	P	implementation:Spi
set_pll_clock_n_multiplier	rcc.rs	/^    pub(crate) fn set_pll_clock_n_multiplier(&self, n: usize) {$/;"	P	implementation:Rcc
set_pll_clock_p_divider	rcc.rs	/^    pub(crate) fn set_pll_clock_p_divider(&self, p: PLLP) {$/;"	P	implementation:Rcc
set_pll_clock_q_divider	rcc.rs	/^    pub(crate) fn set_pll_clock_q_divider(&self, q: PLLQ) {$/;"	P	implementation:Rcc
set_pll_clocks_m_divider	rcc.rs	/^    pub(crate) fn set_pll_clocks_m_divider(&self, m: PLLM) {$/;"	P	implementation:Rcc
set_pll_clocks_source	rcc.rs	/^    pub(crate) fn set_pll_clocks_source(&self, source: PllSource) {$/;"	P	implementation:Rcc
set_polarity	spi.rs	/^    fn set_polarity(&self, polarity: ClockPolarity) -> Result<(), ErrorCode> {$/;"	P	implementation:Spi
set_polarity	spi.rs	/^    fn set_polarity(&self, polarity: ClockPolarity) {$/;"	P	implementation:Spi
set_ports_ref	gpio.rs	/^    pub fn set_ports_ref(&self, ports: &'a GpioPorts<'a>) {$/;"	P	implementation:Pin
set_pullup_pulldown	gpio.rs	/^    fn set_pullup_pulldown(&self, pupd: PullUpPullDown) {$/;"	P	implementation:Pin
set_rate	spi.rs	/^    fn set_rate(&self, rate: u32) -> Result<u32, ErrorCode> {$/;"	P	implementation:Spi
set_receive_client	usart.rs	/^    fn set_receive_client(&self, client: &'a dyn hil::uart::ReceiveClient) {$/;"	P	implementation:Usart
set_speed	gpio.rs	/^    pub fn set_speed(&self) {$/;"	P	implementation:Pin
set_speed	i2c.rs	/^    pub fn set_speed(&self, speed: I2CSpeed, system_clock_in_mhz: usize) {$/;"	P	implementation:I2C
set_sys_clock_source	clk/clocks.rs	/^    pub fn set_sys_clock_source(&self, source: SysClockSource) -> Result<(), ErrorCode> {$/;"	P	implementation:Clocks
set_sys_clock_source	rcc.rs	/^    pub(crate) fn set_sys_clock_source(&self, source: SysClockSource) {$/;"	P	implementation:Rcc
set_transfer_mode_for_peripheral	dma.rs	/^    fn set_transfer_mode_for_peripheral(&self) {$/;"	P	implementation:Stream
set_transmit_client	usart.rs	/^    fn set_transmit_client(&self, client: &'a dyn hil::uart::TransmitClient) {$/;"	P	implementation:Usart
set_wake_up	can.rs	/^    fn set_wake_up(&self, wake_up: bool) -> Result<(), kernel::ErrorCode> {$/;"	P	implementation:Can
setup	dma.rs	/^    pub fn setup(&self, pid: DMA::Peripheral) {$/;"	P	implementation:Stream
setup_circular_deps	chip.rs	/^    pub fn setup_circular_deps(&'a self) {$/;"	P	implementation:Stm32f4xxDefaultPeripherals
setup_circular_deps	gpio.rs	/^    pub fn setup_circular_deps(&'a self) {$/;"	P	implementation:GpioPorts
slave_address	i2c.rs	/^    slave_address: Cell<u8>,$/;"	m	struct:I2C
sleep	chip.rs	/^    fn sleep(&self) {$/;"	P	implementation:Stm32f4xx
smcr	tim2.rs	/^    smcr: ReadWrite<u32, SMCR::Register>,$/;"	m	struct:Tim2Registers
smpr1	adc.rs	/^    smpr1: ReadWrite<u32, SMPR1::Register>,$/;"	m	struct:AdcRegisters
smpr2	adc.rs	/^    smpr2: ReadWrite<u32, SMPR2::Register>,$/;"	m	struct:AdcRegisters
specify_chip_select	spi.rs	/^    fn specify_chip_select(&self, cs: Self::ChipSelect) -> Result<(), ErrorCode> {$/;"	P	implementation:Spi
spi	lib.rs	/^pub mod spi;$/;"	n
spi3	chip.rs	/^    pub spi3: crate::spi::Spi<'a>,$/;"	m	struct:Stm32f4xxDefaultPeripherals
sqr1	adc.rs	/^    sqr1: ReadWrite<u32, SQR1::Register>,$/;"	m	struct:AdcRegisters
sqr2	adc.rs	/^    sqr2: ReadWrite<u32, SQR2::Register>,$/;"	m	struct:AdcRegisters
sqr3	adc.rs	/^    sqr3: ReadWrite<u32, SQR3::Register>,$/;"	m	struct:AdcRegisters
sr	adc.rs	/^    sr: ReadWrite<u32, SR::Register>,$/;"	m	struct:AdcRegisters
sr	spi.rs	/^    sr: ReadWrite<u32, SR::Register>,$/;"	m	struct:SpiRegisters
sr	tim2.rs	/^    sr: ReadWrite<u32, SR::Register>,$/;"	m	struct:Tim2Registers
sr	trng.rs	/^    sr: ReadWrite<u32, Status::Register>,$/;"	m	struct:RngRegisters
sr	usart.rs	/^    sr: ReadWrite<u32, SR::Register>,$/;"	m	struct:UsartRegisters
sr1	i2c.rs	/^    sr1: ReadWrite<u32, SR1::Register>,$/;"	m	struct:I2CRegisters
sr2	i2c.rs	/^    sr2: ReadWrite<u32, SR2::Register>,$/;"	m	struct:I2CRegisters
sscgr	rcc.rs	/^    sscgr: ReadWrite<u32, SSCGR::Register>,$/;"	m	struct:RccRegisters
start	tim2.rs	/^    fn start(&self) -> Result<(), ErrorCode> {$/;"	P	implementation:Tim2
start	tim2.rs	/^    pub fn start(&self) {$/;"	P	implementation:Tim2
start_read	i2c.rs	/^    fn start_read(&self) {$/;"	P	implementation:I2C
start_receive_process	can.rs	/^    fn start_receive_process($/;"	P	implementation:Can
start_write	i2c.rs	/^    fn start_write(&self) {$/;"	P	implementation:I2C
status	adc.rs	/^    status: Cell<ADCStatus>,$/;"	m	struct:Adc
status	i2c.rs	/^    status: Cell<I2CStatus>,$/;"	m	struct:I2C
stop	i2c.rs	/^    fn stop(&self) {$/;"	P	implementation:I2C
stop	tim2.rs	/^    fn stop(&self) -> Result<(), ErrorCode> {$/;"	P	implementation:Tim2
stop_receive	can.rs	/^    fn stop_receive(&self) -> Result<(), kernel::ErrorCode> {$/;"	P	implementation:Can
stop_sampling	adc.rs	/^    fn stop_sampling(&self) -> Result<(), ErrorCode> {$/;"	P	implementation:Adc
str	rcc.rs	/^    type Error = &'static str;$/;"	v	implementation:AHBPrescaler
str	rcc.rs	/^    type Error = &'static str;$/;"	v	implementation:APBPrescaler
str	rcc.rs	/^    type Error = &'static str;$/;"	v	implementation:PLLQ
str	rcc.rs	/^    type Error = &'static str;$/;"	v	implementation:SysClockSource
stream_set_channel	dma.rs	/^    fn stream_set_channel(&self, channel_id: ChannelId) {$/;"	P	implementation:Stream
stream_set_data_width	dma.rs	/^    fn stream_set_data_width(&self, msize: Msize, psize: Psize) {$/;"	P	implementation:Stream
stream_set_direction	dma.rs	/^    fn stream_set_direction(&self, direction: Direction) {$/;"	P	implementation:Stream
stream_set_peripheral_address	dma.rs	/^    fn stream_set_peripheral_address(&self, address: u32) {$/;"	P	implementation:Stream
stream_set_transfer_mode	dma.rs	/^    fn stream_set_transfer_mode(&self, transfer_mode: TransferMode) {$/;"	P	implementation:Stream
streamid	dma.rs	/^    streamid: StreamId,$/;"	m	struct:Stream
swier	exti.rs	/^    swier: ReadWrite<u32, SWIER::Register>,$/;"	m	struct:ExtiRegisters
syscfg	exti.rs	/^    syscfg: &'a syscfg::Syscfg<'a>,$/;"	m	struct:Exti
syscfg	lib.rs	/^pub mod syscfg;$/;"	n
test_clocks_struct	clk/clocks.rs	/^    pub fn test_clocks_struct(clocks: &Clocks) {$/;"	f	module:tests
test_get_number_wait_cycles_based_on_frequency	flash.rs	/^    pub fn test_get_number_wait_cycles_based_on_frequency(flash: &Flash) {$/;"	f	module:tests
test_pll_config	clk/pll.rs	/^    pub fn test_pll_config() {$/;"	f	module:tests
test_pll_struct	clk/pll.rs	/^    pub fn test_pll_struct<'a>(pll: &'a Pll<'a>) {$/;"	f	module:tests
test_set_flash_latency	flash.rs	/^    pub fn test_set_flash_latency(flash: &Flash) {$/;"	f	module:tests
tests	clk/clocks.rs	/^pub mod tests {$/;"	n
tests	clk/hsi.rs	/^pub mod tests {$/;"	n
tests	clk/pll.rs	/^pub mod tests {$/;"	n
tests	flash.rs	/^pub mod tests {$/;"	n
tim2	chip.rs	/^    pub tim2: crate::tim2::Tim2<'a>,$/;"	m	struct:Stm32f4xxDefaultPeripherals
tim2	lib.rs	/^pub mod tim2;$/;"	n
toggle	gpio.rs	/^    fn toggle(&self) -> bool {$/;"	P	implementation:Pin
toggle_output	gpio.rs	/^    fn toggle_output(&self) -> bool {$/;"	P	implementation:Pin
transfer_done	dma.rs	/^    fn transfer_done(&self, pid: DMA::Peripheral);$/;"	P	interface:StreamClient
transfer_done	spi.rs	/^    fn transfer_done(&self, pid: Dma1Peripheral) {$/;"	P	implementation:Spi
transfer_done	usart.rs	/^    fn transfer_done(&self, pid: DMA::Peripheral) {$/;"	P	implementation:Usart
transfer_done	usart.rs	/^    fn transfer_done(&self, pid: dma::Dma1Peripheral) {$/;"	P	implementation:Usart
transfer_done	usart.rs	/^    fn transfer_done(&self, pid: dma::Dma2Peripheral) {$/;"	P	implementation:Usart
transfer_mode	dma.rs	/^    fn transfer_mode(&self) -> TransferMode {$/;"	P	implementation:Dma1Peripheral
transfer_mode	dma.rs	/^    fn transfer_mode(&self) -> TransferMode {$/;"	P	implementation:Dma2Peripheral
transfer_mode	dma.rs	/^    fn transfer_mode(&self) -> TransferMode;$/;"	P	interface:StreamPeripheral
transfers_in_progress	spi.rs	/^    transfers_in_progress: Cell<u8>,$/;"	m	struct:Spi
transmit_abort	usart.rs	/^    fn transmit_abort(&self) -> Result<(), ErrorCode> {$/;"	P	implementation:Usart
transmit_buffer	usart.rs	/^    fn transmit_buffer($/;"	P	implementation:Usart
transmit_client	can.rs	/^    transmit_client:$/;"	m	struct:Can
transmit_word	usart.rs	/^    fn transmit_word(&self, _word: u32) -> Result<(), ErrorCode> {$/;"	P	implementation:Usart
trise	i2c.rs	/^    trise: ReadWrite<u32, TRISE::Register>,$/;"	m	struct:I2CRegisters
trng	lib.rs	/^pub mod trng;$/;"	n
try_from	deferred_calls.rs	/^    fn try_from(value: usize) -> Result<DeferredCallTask, ()> {$/;"	P	implementation:DeferredCallTask
try_from	rcc.rs	/^    fn try_from(item: usize) -> Result<Self, Self::Error> {$/;"	P	implementation:AHBPrescaler
try_from	rcc.rs	/^    fn try_from(item: usize) -> Result<Self, Self::Error> {$/;"	P	implementation:APBPrescaler
try_from	rcc.rs	/^    fn try_from(value: u32) -> Result<Self, Self::Error> {$/;"	P	implementation:SysClockSource
try_from	rcc.rs	/^    fn try_from(value: usize) -> Result<Self, Self::Error> {$/;"	P	implementation:PLLQ
tx_buffer	can.rs	/^    tx_buffer: TakeCell<'static, [u8; can::STANDARD_CAN_PACKET_SIZE]>,$/;"	m	struct:Can
tx_client	usart.rs	/^    tx_client: OptionalCell<&'a dyn hil::uart::TransmitClient>,$/;"	m	struct:Usart
tx_dma	spi.rs	/^    tx_dma: OptionalCell<&'a dma::Stream<'a, Dma1<'a>>>,$/;"	m	struct:Spi
tx_dma	usart.rs	/^    tx_dma: OptionalCell<&'a dma::Stream<'a, DMA>>,$/;"	m	struct:Usart
tx_dma_pid	spi.rs	/^    tx_dma_pid: Dma1Peripheral,$/;"	m	struct:Spi
tx_dma_pid	usart.rs	/^    tx_dma_pid: DMA::Peripheral,$/;"	m	struct:Usart
tx_len	i2c.rs	/^    tx_len: Cell<usize>,$/;"	m	struct:I2C
tx_len	usart.rs	/^    tx_len: Cell<usize>,$/;"	m	struct:Usart
tx_position	i2c.rs	/^    tx_position: Cell<usize>,$/;"	m	struct:I2C
txcrcr	spi.rs	/^    txcrcr: ReadOnly<u32>,$/;"	m	struct:SpiRegisters
unmask_interrupt	exti.rs	/^    pub fn unmask_interrupt(&self, lineid: LineId) {$/;"	P	implementation:Exti
usart	lib.rs	/^pub mod usart;$/;"	n
usart1	chip.rs	/^    pub usart1: crate::usart::Usart<'a, dma::Dma2<'a>>,$/;"	m	struct:Stm32f4xxDefaultPeripherals
usart2	chip.rs	/^    pub usart2: crate::usart::Usart<'a, dma::Dma1<'a>>,$/;"	m	struct:Stm32f4xxDefaultPeripherals
usart3	chip.rs	/^    pub usart3: crate::usart::Usart<'a, dma::Dma1<'a>>,$/;"	m	struct:Stm32f4xxDefaultPeripherals
usart_rx_state	usart.rs	/^    usart_rx_state: Cell<USARTStateRX>,$/;"	m	struct:Usart
usart_tx_state	usart.rs	/^    usart_tx_state: Cell<USARTStateTX>,$/;"	m	struct:Usart
userspace_kernel_boundary	chip.rs	/^    fn userspace_kernel_boundary(&self) -> &cortexm4::syscall::SysCall {$/;"	P	implementation:Stm32f4xx
userspace_kernel_boundary	chip.rs	/^    userspace_kernel_boundary: cortexm4::syscall::SysCall,$/;"	m	struct:Stm32f4xx
usize	rcc.rs	/^impl From<AHBPrescaler> for usize {$/;"	c
usize	rcc.rs	/^impl From<APBPrescaler> for usize {$/;"	c
wait_for	can.rs	/^    fn wait_for(times: usize, f: impl Fn() -> bool) -> bool {$/;"	P	implementation:Can
write	fsmc.rs	/^    fn write($/;"	P	implementation:Fsmc
write	i2c.rs	/^    fn write($/;"	P	implementation:I2C
write_byte	spi.rs	/^    fn write_byte(&self, out_byte: u8) -> Result<(), ErrorCode> {$/;"	P	implementation:Spi
write_data	fsmc.rs	/^    fn write_data(&self, _bank: FsmcBanks, _data: u16) {$/;"	P	implementation:Fsmc
write_data	fsmc.rs	/^    fn write_data(&self, bank: FsmcBanks, data: u16) {$/;"	P	implementation:Fsmc
write_read	i2c.rs	/^    fn write_read($/;"	P	implementation:I2C
write_reg	fsmc.rs	/^    fn write_reg(&self, _bank: FsmcBanks, _addr: u16) {$/;"	P	implementation:Fsmc
write_reg	fsmc.rs	/^    fn write_reg(&self, bank: FsmcBanks, addr: u16) {$/;"	P	implementation:Fsmc
